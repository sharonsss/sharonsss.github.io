<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Data Analysis Hints from FreeCodeCamp</title>
    <link href="/2021/01/20/20210120/"/>
    <url>/2021/01/20/20210120/</url>
    
    <content type="html"><![CDATA[<p>记录 FreeCodeCamp 上 Data Analysis using Python 课程中遇到的一些知识点。这部分不是代码实操，而是以选择题的形式理解一些函数的用法。主要涉及到的类库是 Numpy 和 Pandas。</p><a id="more"></a><h2 id="1-np-nan-和-notnull-的用法"><a href="#1-np-nan-和-notnull-的用法" class="headerlink" title="1. np.nan 和 notnull()的用法"></a>1. np.nan 和 notnull()的用法</h2><p>问题：</p><pre><code class="python">Q: 以下代码返回的值是什么？import pandas as pdimport numpy as nps = pd.Series([&#39;a&#39;, 3, np,nan, 1, np.nan])print(s.notnull().sum())</code></pre><p>首先，列表 s 中出现的 <code>np.nan</code>，能够返回什么值呢？</p><p>用 IDE 实际操作一下，返回结果如下：</p><pre><code class="python">&gt;&gt;&gt; print(s)0      a1      32    NaN3      14    NaNdtype: object</code></pre><p>知识点：</p><ol><li><p><code>np.nan</code>是一个 float 类型的数据，结果会显示为 <code>NaN</code>。再 <code>Series</code>中可以进行计算，进行计算时，可以通过 np.sum()得到结果，NaN 默认为 0.0。</p></li><li><p><code>notnull()</code>函数，判断元素是否为空值，是则为 <code>False</code>，否则为 <code>True</code>。上面 <code>s.notnull()</code>返回的结果为：</p></li></ol><pre><code class="python">&gt;&gt;&gt; s.notnull()0     True1     True2    False3     True4    Falsedtype: bool</code></pre><p>其中有三个元素返回结果为 True。</p><p>问题中 <code>s.notnull().sum()</code>，是计算<code>s.notnull()</code>返回结果为 <code>True</code> 的数量是多少个，而不是要这些元素的值相加。因此结果为 <code>3</code>。</p><pre><code class="python">&gt;&gt;&gt; s.notnull().sum()3</code></pre><h2 id="2-fillna-的几种方式"><a href="#2-fillna-的几种方式" class="headerlink" title="2. fillna()的几种方式"></a>2. fillna()的几种方式</h2><p>问题：</p><pre><code class="python">Q: 以下代码返回什么结果？import pandas as pdimport numpy as nps= pd.Series([np.nan, 1, 2, np.nan, 3])s = s.fillna(method=&#39;ffill&#39;)print(s)</code></pre><p>考察 <code>fillna()</code>的用法：填充缺失值。根据 <code>method</code> 参数，分为几种情况：</p><ul><li><p><strong>不指定 <code>method</code> 参数，可填充常数</strong></p></li><li><p><strong><code>method = &#39;ffill&#39; / &#39;pad&#39;</code>，用前一个非缺失值去填充（向下填充）</strong></p></li><li><p><strong><code>method = &#39;bflii&#39; / &#39;backfill&#39;</code>，用后一个非缺失值去填充（向上填充）</strong></p></li></ul><p>另外，可以通过指定 <code>inplace</code> 参数，来决定是否修改原对象；</p><p>指定 <code>limit</code> 参数，来决定填充几个；</p><p>指定 <code>axis</code> 参数，来决定按行填充还是按列填充（<code>axis=1</code> 为按行填充，<code>axis=0</code> 为按列填充）。</p><p>因此，该问题返回的结果为：</p><pre><code class="python">&gt;&gt;&gt; print(s)0    NaN1    1.02    2.03    2.04    3.0dtype: float64</code></pre><h2 id="3-遍历返回词典中的-key-和-value"><a href="#3-遍历返回词典中的-key-和-value" class="headerlink" title="3. 遍历返回词典中的 key 和 value"></a>3. 遍历返回词典中的 key 和 value</h2><p>想要遍历获得词典数据中的键值，有几种方式：</p><pre><code class="python">方式一：a = {&#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: &#39;3&#39;}方式一：for key in a:    print(key, a[key])方式二：for key in a.keys():    print(key, a[key])方式三：for key,value in a.items():       print(key, value)方式四：for (key,value) in a.items():    print(key, value)</code></pre><p>返回结果：</p><pre><code class="python">a 1b 2c 3</code></pre><h2 id="4-a-2-和-a-2-的区别"><a href="#4-a-2-和-a-2-的区别" class="headerlink" title="4. a[:2] 和 a[:, 2]的区别"></a>4. a[:2] 和 a[:, 2]的区别</h2><p>问题：</p><pre><code>Q: 怎么样能返回如下Output的值？a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])# Output:# [[1 2 20 4 5 ]# [6 7 20 9 10]]</code></pre><p>按照问题描述，需要将每一行的第三个数值改为 20。</p><p>这里涉及到如何取值的问题，也需要区分 <code>a[:2]</code>与 <code>a[:, 2]</code>的用法。</p><p>在多行数组中，</p><ul><li><p><code>a[:2]</code>表示索引 0 至 1 行</p></li><li><p><code>a[:, 2]</code>表示所有行的第 3 列</p></li></ul><p>那么在这个问题中，只需要将每一行的第三列改为 20 即可：</p><pre><code>a[:, 2] = 20</code></pre><h2 id="5-1-1-1-1"><a href="#5-1-1-1-1" class="headerlink" title="5. [1:-1, 1:-1]"></a>5. [1:-1, 1:-1]</h2><p>问题：</p><pre><code class="python">Q: 怎样得到如下数组：[[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 5. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]]</code></pre><p>先说解决方法：</p><pre><code class="python">output = np.zeros((7, 7))z = np.ones((5, 5))z[2, 2] = 5output[1:-1, 1:-1] = z&gt;&gt;&gt; print(output)[[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 5. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]]</code></pre><p>思路就是先创建一个 7x7 的、由数值都是<code>0</code>的矩阵数组。然后创建一个 5x5、全部由<code>1</code>组成的矩阵数组。</p><p>之后，通过定位到<code>[2, 2]</code>（第三行第三列）的位置，将该位置的值改为 5。</p><p>然后，将<code>output</code>数组中的 5x5 部分替换为<code>z</code>。这里是通过<code>[1:-1, 1:-1]</code>来定位的。</p><p>这个问题的重点是搞清楚<code>[1:-1, 1:-1]</code>指定的位置到底是在哪。</p><ul><li><p>这里第一组 <code>1:-1</code>，指的是从第二行到倒数第二行</p></li><li><p>第二组 <code>1:-1</code>，指的是从第二列到倒数第二列</p></li></ul><p>这样，就能将原数组中的 5x5 部分用 <code>z</code> 数组替换掉。</p><hr><p><em>参考来源：</em></p><ul><li><em><a href="https://blog.csdn.net/weixin_39549734/article/details/81221276" target="_blank" rel="noopener">fillna()函数详解</a></em></li><li><em><a href="https://blog.csdn.net/houyanhua1/article/details/87855228" target="_blank" rel="noopener">Python pandas，NaN 的判断（isnull(),notnull()），NaN 的处理，缺失处理，dropna()，fillna()</a></em></li><li><em><a href="https://blog.csdn.net/liuyhoo/article/details/80789715" target="_blank" rel="noopener">Python 中列表索引 A[ : 2 ]与 A[ : , 2]的区别</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 中为表格单元格动态添加超链接</title>
    <link href="/2020/12/23/1223/"/>
    <url>/2020/12/23/1223/</url>
    
    <content type="html"><![CDATA[<p>在基于 Vue 做表格的时候，遇到了给表格的单元格内容动态添加超链接的问题。</p><p>因为表格是动态渲染出来的，其中含有变量，数据通过 <code>methods</code> 获取数据库数据，并遍历得来<a id="more"></a>，因此在<code>&lt;td&gt;</code>标签里，首先尝试了 <code>location.href=&#39;/url&#39;</code> 方法。结果发现引用的数据无法通过拼接链接获取到。</p><p>后来便采取了第二种方式：</p><p><strong>在<code>&lt;td&gt;</code>标签中添加<code>&lt;a&gt;</code>标签，在<code>&lt;a&gt;</code>标签里使用 <code>:href=&quot;&quot;</code> 来拼接链接，<code>:href</code>具有绑定意义。</strong></p><p>经过验证，这种方法可取。</p><p>上代码：</p><pre><code class="html">&lt;table&gt;  &lt;tr&gt;    &lt;th&gt;Song name&lt;/th&gt;    &lt;th&gt;Artist&lt;/th&gt;    &lt;th&gt;Duration&lt;/th&gt;    &lt;th&gt;Album&lt;/th&gt;  &lt;/tr&gt;  &lt;tr id=&quot;list&quot; v-for=&quot;item in items&quot;&gt;    &lt;td&gt;      &lt;a :href=&quot;&#39;https://xxx.xxx.com/#/song?id=&#39; + item.song_id&quot; target=&quot;_blank&quot;        &gt;{{ item.song_name }}&lt;/a      &gt;    &lt;/td&gt;    &lt;td&gt;{{ item.artist }}&lt;/td&gt;    &lt;td class=&quot;duration&quot;&gt;{{ item.duration }}&lt;/td&gt;    &lt;td&gt;{{ item.album_name }}&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p>这样，在点击歌曲名时，就可以直接跳转到相应页面。</p><p><code>target=&quot;_blank&quot;</code> 保证点击之后打开新标签页。</p><p><img src="/img/table.png" srcset="/img/loading.gif" alt=""></p><p><strong><code>&lt;a&gt;</code>标签中<code>href</code>有变量，链接拼接时注意：</strong></p><p>1.<code>href</code> 前面要加<code>“ : ”</code>。Vue 标签里有变量的时候，需要使用<code>:href</code>这种写法。</p><p>2.链接中的字符串用单引号<code>“ ’ ”</code>包住。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 生成随机排序且不重复数组的几种方式</title>
    <link href="/2020/11/20/1119/"/>
    <url>/2020/11/20/1119/</url>
    
    <content type="html"><![CDATA[<p>在项目进行过程中，遇到了需要<strong>生成随机排序且不重复的数组</strong>的问题（指定长度）。在网上研究了一下发现，有两种方式。</p><ol><li>在指定长度范围内，利用 <code>Math.random()</code>，生成不重复的随机数组</li><li>利用 <code>Math.random()</code>和 <code>sort()</code>函数，生成不重复的随机数组</li></ol><a id="more"></a><p>两种方式各有利弊，接下来分别说一下。</p><h2 id="1-利用-Math-random-，比较相同数值，排除重复"><a href="#1-利用-Math-random-，比较相同数值，排除重复" class="headerlink" title="1. 利用 Math.random()，比较相同数值，排除重复"></a>1. 利用 Math.random()，比较相同数值，排除重复</h2><p>这种方式分两部，首先不考虑重复问题，生成指定长度的随机数组；然后，判断该数组中是否有重复的值，如果没有，该数组才会最终生成。</p><p>用代码表示：</p><pre><code class="js">// 定义随机数组var randArr = new Array();// when data.length is more then or equal to 12if (data.length &gt;= 12) {  // TRY 1: 生成一组随机数的数组  // 会导致有重复数字的时候，程序不执行  for (var i = 0; i &lt; 10; i++) {    var num = Math.floor(Math.random() * data.length);    // 判断数组中是否有重复的值    for (var index = 0; index &lt; randArr.length; index++) {      // 如果有，则程序不执行      if (randArr[index] == num) {        return false;      }    }    // 没有重复的情况下，才会最终生成数组    randArr.push(num);  }  console.log(randArr);}</code></pre><p>这种方法有一个很明显的问题：当数组中有重复值的时候，程序会返回 <code>false</code>，这意味着在这种情况下，我们没办法获取这组数值，有重复的数组不会被 <code>console.log</code> 出来。</p><h2 id="2-利用-sort-函数，实现随机排序且不重复"><a href="#2-利用-sort-函数，实现随机排序且不重复" class="headerlink" title="2. 利用 sort()函数，实现随机排序且不重复"></a>2. 利用 sort()函数，实现随机排序且不重复</h2><p>网上有一种比较常用的方法是使用 JS 的 <code>sort()</code>函数。</p><p><code>sort()</code>结合 <code>Math.random()</code>，实现方法如下：</p><pre><code class="js">// 定义随机数组var randArr = new Array();// when data.length is more then or equal to 12if (data.length &gt;= 12) {// TRY 2: 生成一组随机数的数组    // 先创建data长度的数组，给数组整体随机排序（此时可保证没有重复），再取前12位数作为新的数组    for (var i = 0; i &lt; data.length; i++) {        randArr.push(i);    }    randArr.sort(function () {        return 0.5 - Math.random();    });    randArr.length = 12;    console.log(randArr);</code></pre><p>ES6 的写法：</p><pre><code class="js">//ES6function shuffle(arr) {  arr.sort(() =&gt; Math.random() - 0.5);}</code></pre><p>这种方法的优点是，<strong>不会出现重复值。</strong></p><p>缺点是，排序之前需要根据 <code>data</code> 长度先生成一个整体数组，然后在对整体数组进行。当排序数据量大时，运行效率低，性能慢。</p><p>如果只需要从大数组里取较小长度的值，效率比较低。</p><h3 id="sort-方法并不能实现真正的“随机”"><a href="#sort-方法并不能实现真正的“随机”" class="headerlink" title="sort()方法并不能实现真正的“随机”"></a>sort()方法并不能实现真正的“随机”</h3><p>我后来在网上研究了一下发现，虽然这个函数常用，但是最终实现的随机排序，并不是真正的“随机”。</p><p>解释的比较好的是这篇博客：</p><p><em><a href="https://blog.csdn.net/Bule_daze/article/details/103971587" target="_blank" rel="noopener"><code>arr.sort(() =&gt; Math.random() - 0.5);</code> 不能真正地随机打乱数组</a></em></p><p>主要原因总结一下就是，在执行这种方法之后会发现，数组里的每个元素仍然有很大机率在它原来的位置附近出现。</p><p>当数组长度小于 <code>10</code> 时，其中某个元素多次出现的分布可能是这样的：</p><p><img src="/img/distribution1.png" srcset="/img/loading.gif" alt="distribution1"></p><p><img src="/img/distribution2.png" srcset="/img/loading.gif" alt="distribution2"></p><p>当数组长度大于 <code>10</code> 时，其中某个元素多次出现的分布又可能是这样：</p><p><img src="/img/distribution3.png" srcset="/img/loading.gif" alt="distribution3"></p><p>国外有人将结果进行了可视化展示，在下边的展示中，也能够看出 <code>sort()</code>方法存在的问题。</p><p><img src="/img/distribution.png" srcset="/img/loading.gif" alt="distribution"></p><p><strong>以上说明：</strong></p><p><strong>这种随机排序方法确实有一定的随机性，但是大致分布趋势却并不是平均分布的。如果应用此方法，会导致最后的随机排序结果不准确。</strong></p><p>其他方式等实际研究之后再补充。</p><hr><p><strong>参考来源：</strong></p><ul><li><p><em><a href="https://blog.csdn.net/Bule_daze/article/details/103971587" target="_blank" rel="noopener"><code>arr.sort(() =&gt; Math.random() - 0.5);</code> 不能真正地随机打乱数组 (关于 JavaScript 的数组随机排序)）</a></em></p></li><li><p><em><a href="https://bost.ocks.org/mike/shuffle/compare.html" target="_blank" rel="noopener">Will It Shuffle?</a></em></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 数字取整方法（int，ceil、round、modf）</title>
    <link href="/2020/11/16/1116/"/>
    <url>/2020/11/16/1116/</url>
    
    <content type="html"><![CDATA[<p>歌单项目中用到了一些小知识点，这里记录一下: Python 和 JavaScript 在进行数字取整时的几种用法。</p><a id="more"></a><h2 id="Python-对数字取整"><a href="#Python-对数字取整" class="headerlink" title="Python 对数字取整"></a>Python 对数字取整</h2><p>Python 对数字取整有这样几种情况：</p><ol><li><p><strong>int()</strong>: 直接去掉小数点后的值，不考虑是否进位等问题（向下取整），例如 3.8 取 3</p></li><li><p><strong>math.ceil()</strong>: 向上取整，例如 2.4 取 3</p></li><li><p><strong>round()</strong>: 四舍五入</p></li></ol><p>这几种方式的 Python 实现如下：</p><pre><code class="python">import mathfloat1 = 3.24float2 = 2.1float3 = 5.89# 向下取整print(int(float1), int(float2), int(float3))# 向上取整print(math.ceil(float1), math.ceil(float2), math.ceil(float3))# 四舍五入print(round(float1), round(float2), round(float3))</code></pre><p>输出的结果如下：</p><pre><code class="python">&quot;&quot;&quot;3   2   54   3   63   2   6&quot;&quot;&quot;</code></pre><p>另外，还有一个方法可以将 float 值返回为一个元组——<code>math.modf()</code>。整数部分以浮点形式表示。</p><p>不过，该方法返回的小数部分会存在偏差。</p><p>这是由于计算机采用二进制计算，而我们需要运算的是十进制数。在小数部分无法通过乘 2 达到 0 的时候，该方法计算出来的结果，精度就会存在偏差。</p><p>比如：</p><pre><code class="python">import mathprint(math.modf(2.4))</code></pre><p>最后会输出：<strong>(0.3999999999999999, 2.0)</strong>。</p><h2 id="JavaScript-对数字取整"><a href="#JavaScript-对数字取整" class="headerlink" title="JavaScript 对数字取整"></a>JavaScript 对数字取整</h2><p>在 JavaScript 中 ，上面三种取整方式对应的方法如下；</p><pre><code class="js">// 1. 向下取整,丢弃小数部分Math.floor(5 / 2); // 2// 2. 向上取整,有小数就整数部分加1Math.ceil(5 / 2); // 3// 3. 四舍五入Math.round(5 / 2); // 3</code></pre><p>注意，与<code>Math.floor()</code>容易混淆的方法是<code>parseInt()</code>，两者实际上是存在很大区别的。</p><ol><li><p>parseInt() 是类型转换，能够转换任意字符串为整数，在转换数值时，能达到向下取整的效果。Math.floor() 不能解析字符串。</p></li><li><p>两者在转换负数时，结果也不相同。</p></li></ol><p>比如：</p><pre><code class="js">Math.floor(-0.2); //结果 -1Math.floor(-4.3); //结果 -5parseInt(-0.2); //结果 0parseInt(-4.3); //结果 -4</code></pre><p><strong>使用时要注意区分。</strong></p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://www.cnblogs.com/huangqihui/p/12125109.html" target="_blank" rel="noopener">python 对数字的四种取整方法（int，ceil，round，modf）</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 将毫秒转换为“分：秒”的形式</title>
    <link href="/2020/11/16/1116-2/"/>
    <url>/2020/11/16/1116-2/</url>
    
    <content type="html"><![CDATA[<p>在使用网易云 API 获取数据的时候，我发现，网易云上每首歌的时长是以毫秒的格式表示的。数据抓取下来之后，还要将其处理成 <strong>“分: 秒”</strong> 的格式。</p><p><img src="/img/duration.jpg" srcset="/img/loading.gif" alt="duration"></p><p>最终实现的处理方式比较典型，在这里记录一下。</p><a id="more"></a><h2 id="将-“毫秒”-转换为-“分-秒”"><a href="#将-“毫秒”-转换为-“分-秒”" class="headerlink" title="将 “毫秒” 转换为 “分: 秒”"></a>将 “毫秒” 转换为 “分: 秒”</h2><p>首先，毫秒和秒的关系是：</p><p><code>1000 毫秒 = 1 秒</code></p><p>假如一首歌的时长是 287560 毫秒，我们首先需要计算出以“秒”为单位的时长，然后再将“秒”换算成“分：秒”。</p><p>Python 中有一个函数正好适用于这种情况——<code>divmod()</code>。</p><p><code>divmod(a, b)</code> 中 a 表示原始值，b 表示除数，得到的结果为包含商和余数的元组：<code>(a // b, a % b)</code>。</p><p>要将秒转换为（分，秒），那么：</p><pre><code class="python"># a为秒数，b为除数每分钟60秒a, b = 273, 60c, d = divmod(a, b)print(c, d)print (c + &quot;:&quot; + d)</code></pre><p>得到结果：</p><pre><code>(4, 33)(4:33)</code></pre><h2 id="位数不足，自动补-0"><a href="#位数不足，自动补-0" class="headerlink" title="位数不足，自动补 0"></a>位数不足，自动补 0</h2><p>转换后得到的结果是 <code>4:33</code>，可是我想让结果显示为 <code>04:33</code>。那么，就需要在位数不足的时候补上 <code>0</code>。</p><p>这个时候可以使用 <code>zfill(width)</code> 方法，<code>width</code> 为返回的字符串长度，输入类型和返回类型都是<strong>字符串</strong>。</p><p>比如：</p><pre><code class="python"># 当“分”只有一位时，自动在数字前补0if len(str(c))) &lt; 2 :    c = str(c).zfill(2)# 当“秒”只有一位时，自动在数字前补0if len(str(d))) &lt; 2 :    c = str(d).zfill(2)print(c + &#39;:&#39; + d)</code></pre><p>得到结果：</p><pre><code>(04:33)</code></pre><p>转换完成。</p><hr><p><strong>参考来源：</strong></p><ul><li><p><em><a href="https://www.runoob.com/python/python-func-divmod.html" target="_blank" rel="noopener">Python divmod() 函数）</a></em></p></li><li><p><em><a href="https://www.cnblogs.com/zhanglianbo/p/6202683.html" target="_blank" rel="noopener">Python 自动给数字前面补 0）</a></em></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【歌单推荐】Node.js + Express 搭建后端服务器</title>
    <link href="/2020/11/12/1112/"/>
    <url>/2020/11/12/1112/</url>
    
    <content type="html"><![CDATA[<blockquote><p>从零开始，利用 Vue、Node.js、Express、MySQL 实现前后端分离开发。<br>花费半天时间搭建完成，小网站有了崛起的底气。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过第一步的<a href="https://sharonsss.github.io/2020/11/11/1111/" target="_blank" rel="noopener">数据准备</a>，设置好本地数据库名称与端口之后，便将数据整体导入了 MySQL。数据库方面的准备就做好了。</p><p>第二步就是搭建<strong>后端服务器</strong>了，用 <strong>Node.js+Express</strong> 来实现。</p><ul><li><p>目标：后端服务器能够成功启动，成功连接数据库，并能在前端成功获取数据</p></li><li><p>工作时长：0.5 天</p></li></ul><h2 id="利用-Vue-CLI，创建基于-Webpack-模版的一个基本项目结构"><a href="#利用-Vue-CLI，创建基于-Webpack-模版的一个基本项目结构" class="headerlink" title="利用 Vue CLI，创建基于 Webpack 模版的一个基本项目结构"></a>利用 Vue CLI，创建基于 Webpack 模版的一个基本项目结构</h2><p>如何使用 Vue-cli 创建新项目在之前的文章里有写，这里直接记录下操作：</p><pre><code>使用@vue/cli之后，需要全局安装cli-initnpm install -g @vue/cli-init再运行vue init webpack appname</code></pre><p>回车之后，选择默认的项目信息。可以选择自动安装依赖，这样就不用自己再手动安装。</p><p>安装 <code>vue-resource</code>：</p><pre><code>npm install vue-resource --save</code></pre><p>启动项目，按照 <code>README</code> 说明，执行：</p><pre><code>cd appnamenpm run dev</code></pre><p>看到初始化的页面如下，默认端口为 <code>8080</code>：</p><p><img src="/img/vue_init.png" srcset="/img/loading.gif" alt="vue初始化"></p><h2 id="Node-js-搭建后端服务器"><a href="#Node-js-搭建后端服务器" class="headerlink" title="Node.js 搭建后端服务器"></a>Node.js 搭建后端服务器</h2><h3 id="1-新建-server-文件夹"><a href="#1-新建-server-文件夹" class="headerlink" title="1. 新建 server 文件夹"></a>1. 新建 server 文件夹</h3><p>首先，在刚刚创建的项目根目录下，新建一个<code>server</code>文件夹，作为后端服务器的路径。</p><p><img src="/img/server_folder.jpg" srcset="/img/loading.gif" alt="server"></p><p><code>server</code> 文件夹内的目录结构如下：</p><pre><code>|-- server    |-- api        |-- userApi.js    |-- utils        |-- DBHelper.js    |-- index.js    |-- sqlMap.js    |-- package.json</code></pre><h3 id="2-初始化-package-json"><a href="#2-初始化-package-json" class="headerlink" title="2. 初始化 package.json"></a>2. 初始化 package.json</h3><p>在 <code>server</code> 根目录下运行：</p><pre><code>npm init -y</code></pre><p>生成默认的 <code>package.json</code> 文件。</p><h3 id="3-配置-MySQL-数据库的连接文件"><a href="#3-配置-MySQL-数据库的连接文件" class="headerlink" title="3. 配置 MySQL 数据库的连接文件"></a>3. 配置 MySQL 数据库的连接文件</h3><ul><li><p>utils/DBHelper.js –&gt; 进行数据库连接的基本配置</p></li><li><p>sqlMap.js –&gt; 配置 MySQL 语句，根据实际需要来配置</p></li></ul><p>首先，<code>DBHelper.js</code> 里设置好数据库的访问端口、用户名、密码等信息：</p><pre><code class="js">// connect to mysqlconst mysql = require(&quot;mysql&quot;);class DBHelper {  // get connection  getConn() {    let conn = mysql.createConnection({      // basic info (local DB)      host: &quot;127.0.0.1&quot;, // IP address      port: &quot;3306&quot;,      user: &quot;xxx&quot;,      password: &quot;xxx&quot;,      database: &quot;databasename&quot;, // your DB name    });    conn.connect();    return conn;  }}module.exports = DBHelper;</code></pre><p>然后，<code>sqlMap.js</code> 里写好 SQL 语句，这样 Api 可以直接调用：</p><pre><code class="js">// sql queryvar sqlMap = {  songslist: {    select: &#39;select * from songslist where artist like &quot;%&quot;?&quot;%&quot;&#39;,  },};module.exports = sqlMap;</code></pre><p><code>%</code> 表示任意 0 个或多个字符，可匹配任意类型和长度的字符，如果是中文，使用两个 <code>%</code> 表示（<code>%%</code>）。</p><p>上面语句中的 <code>&quot;%&quot;?&quot;%&quot;</code>，可匹配任意字符，即使只输入一个字符，适用于后面需要查询的动作。</p><h3 id="4-配置-Api-文件"><a href="#4-配置-Api-文件" class="headerlink" title="4. 配置 Api 文件"></a>4. 配置 Api 文件</h3><ul><li>api/userApi.js</li></ul><p>Api 文件里是和数据库连接的各个动作的接口。</p><p><code>sqlMap.js</code> 文件里，我只写了一个查询的动作，因此相应的接口也就是一个。（因为暂时不涉及到用户添加的动作，暂时不记录这部分，如果后面需要再增加。）</p><pre><code class="js">const express = require(&quot;express&quot;);const router = express.Router();const DBHelper = require(&quot;../utils/DBHelper&quot;);const sql = require(&quot;../sqlMap&quot;);router.post(&quot;/selectSong&quot;, (req, res) =&gt; {  // 获取 sql select 语句  let sqlStr = sql.songslist.select;  let params = req.body;  let conn = new DBHelper().getConn();  // query 获取数据  conn.query(sqlStr, [params.artist], (err, result) =&gt; {    if (err) {      res.json(err);    } else {      res.json(result);    }  });  conn.end();});module.exports = router;</code></pre><p>如果是多个 sql 语句，就分别写多个 <code>query</code> 请求，把每个动作分开。</p><h3 id="5-配置服务器入口文件-index-js"><a href="#5-配置服务器入口文件-index-js" class="headerlink" title="5. 配置服务器入口文件 index.js"></a>5. 配置服务器入口文件 index.js</h3><p><code>server</code> 根目录下的 <code>index.js</code> 文件，是后端服务器的入口文件。</p><p>在这里设置后端 Api 路由，以及监听的端口：</p><pre><code class="js">// Node 后端端服务器const http = require(&quot;http&quot;);const bodyParser = require(&quot;body-parser&quot;);const express = require(&quot;express&quot;);const userApi = require(&quot;./api/userApi&quot;); // Api路径let app = express();let server = http.createServer(app);app.use(bodyParser.json());app.use(  bodyParser.urlencoded({    extended: false,  }));// 解决 Access-Control-Allow-Origin 跨域问题app.all(&quot;*&quot;, function (req, res, next) {  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With,Content-Type&quot;);  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  next();});// 后端API路由app.use(&quot;/api/songslist&quot;, userApi);// 启动监听server.listen(8888, () =&gt; {  console.log(&quot;Success! PORT: 8888&quot;);});</code></pre><p>设置后端服务器的端口为 <code>8888</code>。</p><h3 id="6-启动后端服务器"><a href="#6-启动后端服务器" class="headerlink" title="6. 启动后端服务器"></a>6. 启动后端服务器</h3><ol><li>在项目根目录下安装依赖：</li></ol><pre><code>npm install express mysql body-parser</code></pre><ol start="2"><li>在 <code>server</code> 文件夹下执行命令，启动服务器：</li></ol><pre><code>node index.jsornode index</code></pre><p>服务器启动成功后，看到提示信息，说明启动成功啦！</p><p><img src="/img/start.png" srcset="/img/loading.gif" alt="启动"></p><h2 id="Vue-前端简单测试，获取数据"><a href="#Vue-前端简单测试，获取数据" class="headerlink" title="Vue 前端简单测试，获取数据"></a>Vue 前端简单测试，获取数据</h2><h3 id="1-基础页面"><a href="#1-基础页面" class="headerlink" title="1. 基础页面"></a>1. 基础页面</h3><p>因为这一步主要测试能否成功从数据库获取数据，前端的页面直接在 <code>HelloWorld.vue</code>组建中修改一下。</p><p>注册一个 <code>selectSong</code> 点击事件，用户输入的信息注册为 <code>keywords</code>，点击按钮即可查询返回相应的信息。</p><p>代码如下：</p><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;h1&gt;{{ msg }}&lt;/h1&gt;    &lt;form action=&quot;&quot;&gt;      &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot; placeholder=&quot;输入artist&quot; /&gt;      &lt;button type=&quot;button&quot; @click=&quot;selectSong&quot;&gt;查询&lt;/button&gt;      &lt;h2&gt;{{ name }}&lt;/h2&gt;    &lt;/form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;HelloWorld&quot;,  data() {    return {      msg: &quot;Welcome to Your Vue.js App&quot;,      keywords: &quot;&quot;,      name: &quot;&quot;,    };  },  methods: {    // select song event    selectSong() {        // 输入为 artist      let artist = this.keywords;      this.axios        .post(&quot;/api/songslist/selectSong&quot;, {          artist,        })        .then((res) =&gt; {          let data = res.data[0];     // 测试只取第一组数据          // 输出artist对应的歌曲名称          this.name = data.song_name;        })        .catch((err) =&gt; {          console.log(err);        });    },  },};&lt;/script&gt;</code></pre><h3 id="2-vue-cli-引入-axios-以及跨域使用"><a href="#2-vue-cli-引入-axios-以及跨域使用" class="headerlink" title="2. vue-cli 引入 axios 以及跨域使用"></a>2. vue-cli 引入 axios 以及跨域使用</h3><p>代码中使用了 axios，首先需要安装并引入 axios。</p><ol><li>在根目录下安装 <code>axios</code> 和 <code>vue-axios</code></li></ol><pre><code>npm install axiosnpm install vue-axios</code></pre><ol start="2"><li>在 <code>main.js</code> 文件中导入 <code>axios</code> 和 <code>vue-axios</code>，并改写原型链</li></ol><pre><code class="js">import axios from &quot;axios&quot;;import VueAxios from &quot;vue-axios&quot;;Vue.use(VueAxios, axios);// 改写原型链Vue.prototype.$axios = axios;</code></pre><p>这样，<code>axios</code> 就可以正常使用了，注意在 Vue 代码中，使用 <code>axios</code> 时前面要加<code>this</code>：</p><pre><code>this.axios.post(&#39;&#39;, {})</code></pre><h3 id="3-客户端（Vue-前端）和后端服务器之间的跨域问题"><a href="#3-客户端（Vue-前端）和后端服务器之间的跨域问题" class="headerlink" title="3. 客户端（Vue 前端）和后端服务器之间的跨域问题"></a>3. 客户端（Vue 前端）和后端服务器之间的跨域问题</h3><p>解决了 <code>axios</code> 的引用，启动客户端之后，发现本地代理的跨域问题。</p><p>在本地 localhost 访问本地服务器的地址<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>是要跨域的，浏览器的安全策略，会报错。</p><p>需要配置一下 <code>config</code> 文件夹中的 <code>index.js</code> 文件：<code>config/index.js --&gt; proxyTable</code></p><pre><code class="js">dev: {    // 加入以下    proxyTable: {      &#39;/api&#39;: {        target: &#39;http://127.0.0.1:8888/&#39;,//设置调用的接口域名和端口号 别忘了加http        changeOrigin: true,//如果需要跨域        pathRewrite: {          &#39;^/api&#39;: &#39;/api&#39;        }      }    },</code></pre><h3 id="4-Access-Control-Allow-Origin-跨域问题"><a href="#4-Access-Control-Allow-Origin-跨域问题" class="headerlink" title="4. Access-Control-Allow-Origin 跨域问题"></a>4. Access-Control-Allow-Origin 跨域问题</h3><p>除了本地代理跨域问题，启动客户端时发现还产生了 <code>Access-Control-Allow-Origin</code> 跨域问题。</p><p>这是因为 <code>http</code> 请求头部没有配置允许跨域，需要在后端服务器的 <code>index.js</code> 文件里加入如下代码：</p><pre><code class="js">// 解决 Access-Control-Allow-Origin 跨域问题app.all(&quot;*&quot;, function (req, res, next) {  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With,Content-Type&quot;);  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  next();});</code></pre><p>好了，重新启动服务器，然后启动客户端。</p><p>输入一个歌手的名字，可以看到查询的结果。</p><p><strong>前后端服务连接成功！</strong></p><p><img src="/img/success.png" srcset="/img/loading.gif" alt="s"></p><p><strong>撒花！</strong> 🎉🎉🎉</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://blog.csdn.net/AiHuanhuan110/article/details/90674744" target="_blank" rel="noopener">【全栈初体验】Vue+Node+MySQL 实现前后端分离开发</a></em></li><li><em><a href="https://blog.csdn.net/weixin_42003850/article/details/100511566" target="_blank" rel="noopener">实战 vue+mySql 链接数据库并操作</a></em></li><li><em><a href="https://www.jianshu.com/p/27b37a8cd84b" target="_blank" rel="noopener">vue-cli 引入 axios</a></em></li><li><em><a href="https://www.jianshu.com/p/e36956dc78b8" target="_blank" rel="noopener">vue-cli 引入 axios 及跨域使用</a></em></li><li><em><a href="https://blog.csdn.net/sps900608/article/details/79599121" target="_blank" rel="noopener">使用 axios 解决‘Access-Control-Allow-Origin’跨域</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>MySQL</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【歌单推荐】数据准备：从网易云音乐API获取数据</title>
    <link href="/2020/11/11/1111/"/>
    <url>/2020/11/11/1111/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在准备一个歌单推荐的项目，感谢网易云音乐 API (NodeJS 版) 提供了丰富的数据获取的接口，可以轻松的得到自己想要的数据。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在准备一个【歌单推荐】的项目，准备从获取数据、搭建数据库、Node.js server 再到前端页面开发，从全栈开发的角度完成一个项目。每部分会单独在博客里记录。</p><p>不同部分涉及到的语言和框架计划如下：</p><ol><li><p>基于网易云音乐 API 获取歌单数据（Python）</p></li><li><p>搭建数据库（MySQL）</p></li><li><p>搭建后端服务器（Node.js, Express）</p></li><li><p>前端开发（Vue.js）**</p></li></ol><p>首先第一篇是从获取数据开始。</p><h2 id="网易云音乐-API-NodeJS-版"><a href="#网易云音乐-API-NodeJS-版" class="headerlink" title="网易云音乐 API (NodeJS 版)"></a>网易云音乐 API (NodeJS 版)</h2><p>感谢网易云音乐 API (NodeJS 版) 提供了丰富的数据获取的接口，可以轻松的得到自己想要的数据。</p><p>如果想要自己去网易云上爬取数据也可以，但是相对来说会更麻烦一些。之前帮同学写过一个爬虫小项目，是根据对方提供的歌手名称，去爬取跟这个歌手相关的歌曲、专辑、评论等，自己摸索着去寻找还是花了一些时间。通过 API 接口去获取就简单了很多。</p><p>因为我这次要寻找的数据主要是和歌单、歌曲、歌手、风格相关，因此通过哦对应的借口就可以获取到自己想要的数据。</p><p><img src="/img/api.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以将 API 安装在本地，每次使用 Python 获取数据前，先在本地运行。</p><p>具体的安装运行教程，可以查看<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/" target="_blank" rel="noopener">网易云音乐 API 官方的页面</a>。</p><h2 id="Python-requests-请求数据"><a href="#Python-requests-请求数据" class="headerlink" title="Python requests 请求数据"></a>Python requests 请求数据</h2><p> 这次用到的主要是 <code>requests</code> 请求，通过 <code>requests.get(url)</code> 来请求需要的数据，示例：</p><pre><code class="Python">import requestsimport json# NetEaseCloud APIurl = &quot;http://...&quot;response = requests.get(url)# get response text (unicode)if(response.status_code == 200):    response = response.text    # turn response into dict    json_dict = json.loads(response)    print json_dict</code></pre><p>这时候，将 <code>json_dict</code> 打印出来就是<code>dict</code>格式的文件，我们可以获取里面想要的值。获取方法就是遍历，查看一层一层的结构，找到目标数据所在的位置。</p><p>注意，此时数据为 <code>unicode</code> 字符串，带有<code>u&#39;&#39;</code>，获取的时候注意格式。</p><p><code>requests</code> 开始获取到的是 <code>unicode</code> 的格式的字符串，可以在最开始将 <code>unicode</code> 转换成 <code>utf8</code> 格式，这样，中英字符串就可以正常显示。</p><p>示例：</p><pre><code class="Python">import sys# turn unicode string into utf-8reload(sys)sys.setdefaultencoding(&#39;utf8&#39;)# get user&#39;s playlistjson_list = json_dict[u&#39;playlist&#39;]# get song_name and id from playlistplaylist_name = playlist[u&#39;name&#39;]playlist_id = playlist[u&#39;id&#39;]</code></pre><p>将需要的数据以 list 的形势存储起来。</p><h2 id="将数据存储为-csv-文件"><a href="#将数据存储为-csv-文件" class="headerlink" title="将数据存储为 csv 文件"></a>将数据存储为 csv 文件</h2><p>数据获取到之后，怎么放到得到 MySQL 里呢？</p><p>我用的是比较傻瓜的方式，先将数据存储为 csv 格式的文件，再将整个数据表导入 MySQL（在 MySQL Workbench 里实现起来最简单）。</p><pre><code class="Python">import csv# create a csv file, define header names of each columnfilename = &#39;songslist.csv&#39;f = open(filename, &#39;w&#39;)writer = csv.writer(f)writer.writerow([&#39;song_name&#39;,&#39;song_id&#39;, &#39;artist&#39;, &#39;album_name&#39;, &#39;playlist_name&#39;, &#39;playlist_id&#39;])...# write data to a csv filewriter.writerow([song_name, song_id, artist, album_name, playlist_name, playlist_id])f.close()</code></pre><p>最后写入 csv 文件的数据是这样的：</p><pre><code>song_name,song_id,artist,album_name,playlist_name,playlist_id,category1979,22469981,The Smashing Pumpkins,Mellon Collie And The Infinite Sadness,壹叁肆伍陆柒捌久拾,156108612,110228,33166122,宮内優里,ほんじつのおんがく集 5,ほんじつのおんがく集 5,614617491,folk110308,33166131,宮内優里,ほんじつのおんがく集 5,ほんじつのおんがく集 5,614617491,folk110404,33166128,宮内優里,ほんじつのおんがく集 5,ほんじつのおんがく集 5,614617491,folk L&#39;aquoiboniste,2773962,Jane Birkin,Master Serie Vol. 1-2,Vol.02 只是音乐,102152978,,(Nice Dream),18795427,Radiohead,The Bends,The Bends,456941889,britpop13th,26545024,惘闻,Split,壹叁肆伍陆柒捌久拾,156108612,post_rock15 Ativan (Song for Erika),33111144,Foxes in Fiction,Swung from The Branches,梦幻摇滚 I 倚梦阑香，失真幻象,2667641834,1880 Or So,22290961,Television,Television,过脑,326459617,...</code></pre><p>想要查看数据获取和写入所用的时间，可以借助 datetime 插件来实现：</p><pre><code class="Python">import datetime# counting time from the very beginningstart = datetime.datetime.now()...# calculate running time at the endend = datetime.datetime.now()print &quot;运行时长：&quot;, (end - start)</code></pre><p>这样数据写入完成之后，就可以看到花费的时间。</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://blog.csdn.net/u011817217/article/details/92411009" target="_blank" rel="noopener">网易云音乐 API</a></em></li><li><em><a href="https://www.cnblogs.com/shapeL/p/9037670.html" target="_blank" rel="noopener">python：Json 模块 dumps、loads、dump、load 介绍</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>网易云音乐API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年过半，立起来的FLAG不要倒</title>
    <link href="/2020/06/30/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93-0630/"/>
    <url>/2020/06/30/%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93-0630/</url>
    
    <content type="html"><![CDATA[<p>今天是 2020 年 6 月 30 日，2020 这个不寻常的一年已经过了一半啦。到了半年总结的日子，应该说点啥呢？</p><a id="more"></a><p>年初的时候，大家都说 2020 年会很不寻常，本以为是向好的不寻常，能干一番大事业，却没想到所谓的“不寻常”是各种意想不到的挑战。</p><p>那么，我在年初立下了四大 FLAG，到现在都完成得怎么样呢？</p><p>一个一个来说。</p><h2 id="一、搭建个人技术博客"><a href="#一、搭建个人技术博客" class="headerlink" title="一、搭建个人技术博客"></a>一、搭建个人技术博客</h2><p><strong>成功！</strong></p><p><strong>且正在有条不紊的丰富着。</strong></p><p>每周抽出一两天时间记录遇到的技术问题，其实对我来说会大大增加我对的充实感，对于其他方面的焦虑和负面情绪，有非常好的缓解作用，可以说是很好的精神食粮了。✨</p><p>截止到今天，博客一共更新了 14 篇文章，平均下来一个月两篇。</p><p>主要内容以前端开发为主。</p><p><img src="/img/tags.png" srcset="/img/loading.gif" alt=""></p><p>等等？</p><p>这个数量貌似有点少啊！😂</p><p>实际上，除了年初的一篇宏伟 FLAG 文之外，比较干货的文章是从 3 月底才开始更新的。2、3 月份因为疫情在家，几乎没有更新的动力。</p><p>回顾一下半年来积累的文章，还是有一些干货的。希望下半年能更新更多的干货文章，助我多多学习，天天向上!💪💪</p><h2 id="二、完成一个数据可视化网站项目"><a href="#二、完成一个数据可视化网站项目" class="headerlink" title="二、完成一个数据可视化网站项目"></a>二、完成一个数据可视化网站项目</h2><p>这个目标一直没想好拿什么数据来做，因此也就搁置了。</p><p>另一方面是因为，上半年花时间学习了 <code>Vue.js</code> 相关的知识，这个网站想借助 Vue 来实现。所以网站搭建的进度取决于学习 Vue 的进度。。</p><p>目前尚处于看官方文档和教程的阶段，下半年要开始试手了。</p><p>初步想法是拿现有数据来做，实现数据库端、后端和前端三合一，整体的跑一下 web 开发的重要环节。接下来需要花一些时间想清楚做什么、怎么做。</p><h2 id="三、完成一个微信小程序项目"><a href="#三、完成一个微信小程序项目" class="headerlink" title="三、完成一个微信小程序项目"></a>三、完成一个微信小程序项目</h2><p>这个本来是排在第二个 FLAG 之后要做的，既然第二个没实现，那么这么也暂时没得谱儿。。</p><p>真是惭愧。</p><p>我的精力有限，而且最近有些懒散，学习任务压在肩上却一直没有完成，我要检讨和反省！</p><p>Anyway，等第二个 FLAG 实现了，再计划这个吧。</p><h2 id="四、微信号-百家号"><a href="#四、微信号-百家号" class="headerlink" title="四、微信号/百家号"></a>四、微信号/百家号</h2><p>这个 FLAG 我主要纠结内容方向，之前尝试的并没有太大成果。</p><p>百家号基本放弃，微信号的话，在纠结做技术方向或者是生活方向。</p><p>另外也在思考是不是有其他更好的自媒体平台。</p><p>暂时先这样吧。</p><h2 id="下半年要做的事情"><a href="#下半年要做的事情" class="headerlink" title="下半年要做的事情"></a>下半年要做的事情</h2><ol><li><p>个人博客持续更新</p></li><li><p>web 网站开始搭建，起码有个雏形</p></li><li><p>微信小程序开始研究官方文档和教程，做小 Demo 试手</p></li><li><p>自媒体：确定平台和方向</p></li></ol><br><p><strong>下半年的愿望，依然是希望自己立的 FLAG 不要倒。</strong></p><p><strong>加油！</strong></p><p><img src="/img/2020.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue 学习笔记】VueCli3.x 教程（一）</title>
    <link href="/2020/06/30/vue%E5%AD%A6%E4%B9%A0-0621/"/>
    <url>/2020/06/30/vue%E5%AD%A6%E4%B9%A0-0621/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《VueCli3.x 最新入门教程》主要基于 Vue.js 教程与官方的 API 文档，进行相关的讲解。</p></blockquote><blockquote><p>这篇文章记录第一部分，基于 CDN 进行 Vue 的开发，以及小 Demo 的制作，随堂记录。</p></blockquote><a id="more"></a><h2 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1. 数据绑定"></a>1. 数据绑定</h2><p>数据绑定是 Vue 里的基本实现。</p><ul><li><code>v-bind</code>: 数据绑定（在 html 属性中进行）</li></ul><p>示例：</p><pre><code class="html">&lt;p&gt;  &lt;a v-bind:href=&quot;website&quot;&gt;Baidu&lt;/a&gt;  &lt;a :href=&quot;website&quot;&gt;Baidu&lt;/a&gt;&lt;/p&gt;&lt;!-- &lt;p&gt;{{ websiteTag }}&lt;/p&gt; --&gt;&lt;p&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot; /&gt;&lt;/p&gt;</code></pre><ul><li><code>v-</code>: 叫做“指令”</li></ul><h2 id="2-事件"><a href="#2-事件" class="headerlink" title="2. 事件"></a>2. 事件</h2><ul><li>单击事件 <code>@click</code></li><li>双击事件 <code>@dblclick</code></li><li>鼠标事件 <code>v-on:mousemove</code></li></ul><p>示例：</p><pre><code class="html">&lt;!-- mousemove  event --&gt;&lt;div id=&quot;canvas&quot; v-on:mousemove=&quot;updateXY&quot;&gt;  {{X}}, {{Y}}&lt;/div&gt;</code></pre><ul><li>事件修饰符(<code>.once</code>, <code>.prevent</code>)</li></ul><p>示例：</p><pre><code class="html">&lt;!-- 事件修饰符 .prevent 阻止自动刷新的默认事件 --&gt;&lt;p&gt;&lt;a @click.prevent=&quot;handleClick&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/p&gt;</code></pre><ul><li>键盘事件(<code>keyup</code>, <code>keydown</code>, 加入修饰符)</li></ul><p>示例：</p><pre><code class="html">&lt;!-- 键盘事件--&gt;&lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot; v-on:keydown.enter=&quot;logName&quot; /&gt;&lt;label&gt;年龄&lt;/label&gt;&lt;input type=&quot;text&quot; v-on:keyup.alt.enter=&quot;logAge&quot; /&gt;</code></pre><h2 id="3-双向数据绑定-v-model"><a href="#3-双向数据绑定-v-model" class="headerlink" title="3. 双向数据绑定 v-model"></a>3. 双向数据绑定 v-model</h2><ul><li>v-model：实现数据的输入和输出</li></ul><h2 id="4-特殊特性-ref"><a href="#4-特殊特性-ref" class="headerlink" title="4. 特殊特性 ref"></a>4. 特殊特性 ref</h2><p>通过 <code>ref</code> 获取对应的元素对象，类似 js 中 获取 DOM 的操作。</p><h2 id="5-监听-watch"><a href="#5-监听-watch" class="headerlink" title="5. 监听 watch"></a>5. 监听 watch</h2><p>不建议使用 <code>watch</code>，一般在调试的时候，或者迫不得已的情况。因为会持续监听属性的状态，会影响项目的性能。</p><h2 id="6-计算属性-computed"><a href="#6-计算属性-computed" class="headerlink" title="6. 计算属性 computed"></a>6. 计算属性 computed</h2><ul><li>computed：只有在当前的属性发生变化的时候，才会被触发。</li></ul><p>而 <code>methods</code> 中的属性，首先在一开始时会执行一次，而在之后每次其中一个属性发生变化的时候，另外一个属性也会执行。这样当属性非常多的时候，是非常耗费性能的。而我们只想执行当前操作的这个属性，其他的都不要有任何动作。</p><p>这个时候，就需要引入 <code>computed</code> 计算属性了。</p><ul><li><p><em>调用 <code>methods</code> 方法时，不能加括号。</em></p></li><li><p><code>methods</code> 不一定要 <code>return</code> 属性，<code>computed</code> 必须要有 <code>return</code> 返回值</p></li><li><p>样式需要发生一些变化的时候，以及搜索的时候，可以使用 <code>computed</code>。</p></li></ul><h2 id="7-动态改变样式的两种方式"><a href="#7-动态改变样式的两种方式" class="headerlink" title="7. 动态改变样式的两种方式"></a>7. 动态改变样式的两种方式</h2><ul><li>属性绑定</li></ul><p>花括号：</p><pre><code>{{ 属性名称 }}</code></pre><ul><li>计算属性绑定-样式变化频率高，最好使用计算属性：</li></ul><pre><code class="html">&lt;button @click=&quot;mrChangeColor = !mrChangeColor&quot;&gt;change color&lt;/button&gt;</code></pre><h2 id="8-条件判断-v-if"><a href="#8-条件判断-v-if" class="headerlink" title="8. 条件判断 v-if"></a>8. 条件判断 v-if</h2><p>示例：</p><pre><code class="html">&lt;button @click=&quot;error = !error&quot;&gt;error&lt;/button&gt;</code></pre><ul><li><code>v-show</code> 和 <code>v-if</code> 的区别：</li></ul><p><strong>核心区别在于 DOM</strong></p><p><code>v-if</code> 属性为假时，DOM 中相应的标签会直接被去掉，不会显示。<code>v-show</code> 属性为假时，DOM 中相应的标签 还会存在，只不过会显示 <code>display: none</code>，为真时，<code>display: block</code>。</p><h2 id="9-v-for-遍历数组-对象"><a href="#9-v-for-遍历数组-对象" class="headerlink" title="9. v-for 遍历数组/对象"></a>9. v-for 遍历数组/对象</h2><ul><li><code>v-for</code> 可以用来遍历数组或者对象。</li></ul><p>遍历数组：</p><pre><code class="html">&lt;ul&gt;  &lt;li v-for=&quot;char in characters&quot;&gt;    {{ char}}  &lt;/li&gt;  &lt;li v-for=&quot;(char, index) in characters&quot;&gt;    {{index + 1}} . {{ char}}  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>遍历对象：</p><pre><code class="html">&lt;!-- 遍历对象 --&gt;&lt;template v-for=&quot;(user, index) in users&quot;&gt;  &lt;div v-for=&quot;(val, key) in user&quot;&gt;    &lt;p&gt;{{key}} - {{val}}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="10-Demo-示例-瓶子状态改变"><a href="#10-Demo-示例-瓶子状态改变" class="headerlink" title="10. Demo 示例 (瓶子状态改变)"></a>10. Demo 示例 (瓶子状态改变)</h2><p>详细实现方式后面补充。</p><p>先看下效果：</p><img src="/img/bottle.png" srcset="/img/loading.gif" width="30%"><img src="/img/bottle-restart.png" srcset="/img/loading.gif" width="30%"><h2 id="11-实例化多个-Vue-示例"><a href="#11-实例化多个-Vue-示例" class="headerlink" title="11. 实例化多个 Vue 示例"></a>11. 实例化多个 Vue 示例</h2><ul><li>每个 Vue 实例用 <code>const one</code>、<code>const two</code> 来定义</li></ul><p>在 <code>const two</code> 实例中，可以改变 <code>const one</code> 中的属性的值，比如 <code>title</code>。方式是，调用时将原来的 <code>this</code> 替换成相应的 <code>const</code> 变量，例如 <code>one</code> 或者 <code>two</code>。</p><p>示例：</p><pre><code class="javascript">const one = new Vue({  el: &quot;#vue-app-one&quot;,  data() {    return {      title: &quot;this is vue app one&quot;,    };  },});const two = new Vue({  el: &quot;#vue-app-two&quot;,  data() {    return {      title: &quot;this is vue app two&quot;,    };  },  methods: {    changeAppOneTitle() {      // 原本的 this 替换成对应的定义变量 one      one.title = &quot;这是app-one的新title&quot;;    },  },});</code></pre><p><code>changeAppOneTitle()</code> 方法在 <code>methods</code> 中定义，在 html 中调用：</p><pre><code class="html">&lt;button @click=&quot;changeAppOneTitle&quot;&gt;Change app one title&lt;/button&gt;</code></pre><p>另外，也可以直接在实例外面修改实例内的值，比如：</p><pre><code class="javascript">two.title = &quot;这是app-two的title&quot;;</code></pre><h2 id="12-Vue-component"><a href="#12-Vue-component" class="headerlink" title="12. Vue.component"></a>12. Vue.component</h2><ul><li><code>Vue.component(id, properties)</code> 组建可以单独封装，然后在不同的实例中调用。</li></ul><p>id 为组建的名称，在属性中，可以创建 html 模版，也可以添加其他的属性、方法等。</p><h2 id="13-请求数据"><a href="#13-请求数据" class="headerlink" title="13. 请求数据"></a>13. 请求数据</h2><h3 id="1）fetch-请求"><a href="#1）fetch-请求" class="headerlink" title="1）fetch 请求"></a>1）fetch 请求</h3><p>代码示例：</p><pre><code class="javascript">// Getfetch(&quot;http://jsonplaceholder.typicode.com/todos&quot;)  .then((res) =&gt; {    // console.log(res);    // console.log(res.json());    return res.json();  })  .then((todos) =&gt; {    // console.log(todos);    this.todos = todos;  });// POSTfetch(&quot;http://jsonplaceholder.typicode.com/todos&quot;, {  method: &quot;POST&quot;,  body: JSON.stringify(this.todo),  headers: {    &quot;Content-type&quot;: &quot;application/json&quot;,  },})  .then((res) =&gt; {    return res.json();  })  .then((todo) =&gt; {    // console.log(todo);    this.todos.unshift(todo);  });</code></pre><ul><li><strong><code>unshift()</code> 方法：</strong></li></ul><p><code>unshift()</code> 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><h3 id="2）axios-请求"><a href="#2）axios-请求" class="headerlink" title="2）axios 请求"></a>2）axios 请求</h3><p><strong>axios</strong> 请求相比 <strong>fetch</strong> 代码量少一些，不需要把 <code>response</code> 的数据再经一步 <code>json</code> 转换，而是直接通过 <code>response.data</code> 就能获取。</p><p>本次直接使用 CDN 引入 axios：</p><pre><code class="html">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>axios 请求 API 数据代码示例：</p><pre><code class="javascript">// GETaxios.get(&quot;http://jsonplaceholder.typicode.com/todos&quot;).then((res) =&gt; {  //console.log(res);  this.todos = res.data;});// POSTaxios  .post(&quot;http://jsonplaceholder.typicode.com/todos&quot;, this.todo)  .then((res) =&gt; {    // console.log(res.data);    this.todos.unshift(res.data);  });</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 的基本操作</title>
    <link href="/2020/06/12/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/06/12/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>近期在维护的系统涉及到 <code>MySQL</code> 数据库的一些操作，都比较简单。没学习过数据库操作的知识，先在这里大致记录下用到的一些基本操作。</p><a id="more"></a><h1 id="记录-MySQL-的操作"><a href="#记录-MySQL-的操作" class="headerlink" title="记录 MySQL 的操作"></a>记录 MySQL 的操作</h1><p>主要基于 <code>Terminal</code> 和 <code>Mysql Workbench</code> ，使用中涉及的一些步骤包括：</p><ol><li><p>登陆本地数据库、远程服务器数据库</p></li><li><p>下载远程数据到本地</p></li><li><p>将数据表导入数据库</p></li><li><p>查看数据库中的数据</p></li><li><p>向数据库中添加新数据</p></li><li><p><code>Nginx</code> 图片文件夹添加对应的新图片（上传图片至服务器文件夹）</p></li><li><p>重启系统，测试图片是否成功显示 - <code>YES</code></p></li><li><p>更改系统中 <code>html</code> 静态文件中的部分字段，将更改后的文件重新上传，并打包 <code>jar</code> 包</p></li></ol><p><code>6、7、8</code> 暂时不在这里记录。</p><h1 id="MySQL-数据库的基本操作"><a href="#MySQL-数据库的基本操作" class="headerlink" title="MySQL 数据库的基本操作"></a>MySQL 数据库的基本操作</h1><h2 id="1-在-Terminal-中登录"><a href="#1-在-Terminal-中登录" class="headerlink" title="1. 在 Terminal 中登录"></a>1. 在 <code>Terminal</code> 中登录</h2><p>在 <code>Terminal</code> 中登录本地数据库，比较简单：</p><pre><code>$ mysql -u 用户名 -p 密码</code></pre><p>登录远程服务器：</p><pre><code>$ mysql -u 远程服务器用户名 -p 远程服务器密码(具体密码可不填)  -h 远程服务器IP -P 远程服务器端口（一般为 3306）$ Enter password:</code></pre><p>密码输入正确的话，会出现如下的信息：</p><pre><code>Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is xxxxServer version: 5.7.23 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</code></pre><p>说明成功连接到了远程服务器，接下来就可以进行一些基本操作了。</p><h2 id="2-MySQL-的基本操作"><a href="#2-MySQL-的基本操作" class="headerlink" title="2. MySQL 的基本操作"></a>2. MySQL 的基本操作</h2><p>想要查看系统所在的数据表，定位到具体的某个表格，这样操作（ MySQL 的语句后面要一定要加 <code>;</code> 符号）：</p><p>查看所有的数据库：</p><pre><code>mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || key_data           |+--------------------+2 rows in set (0.00 sec)</code></pre><p>定位到一个具体的数据库中：</p><pre><code>mysql&gt; use key_data;</code></pre><p>查看这个数据库中所有的数据表：</p><pre><code>mysql&gt; show tables;+------------------------------+| Tables_in_gain_external_data |+------------------------------+| table_1                      || table_2                      || table_3                      || table_4                      |+------------------------------+4 rows in set (0.00 sec)</code></pre><p>查看某一个数据表的基本结构：</p><pre><code>mysql&gt; describe table_1;+----------------------+---------------+------+-----+---------+-------+| Field                | Type          | Null | Key | Default | Extra |+----------------------+---------------+------+-----+---------+-------+| id                   | int(11)       | NO   | PRI | 0       |       || chinese              | text          | NO   |     | NULL    |       || english              | text          | NO   |     | NULL    |       || classification1      | varchar(512)  | YES  |     | NULL    |       || classification2      | varchar(512)  | YES  |     | NULL    |       |+----------------------+---------------+------+-----+---------+-------+5 rows in set (0.01 sec)</code></pre><p>预览数据表中前 <code>10</code> 行的数据：</p><pre><code>mysql&gt; SELECT * FROM key_data.table_1 LIMIT 0,10;</code></pre><p>向数据表中添加数据，两种情况：</p><ol><li><p><code>id</code> 存在，只需要为已有 <code>id</code> 的数据添加一些已有字段的信息，使用 <code>update</code>；</p></li><li><p><code>id</code> 不存在，需要完全添加新的数据，使用 <code>insert</code>。 如果表中还有其他字段，而且是必须填的，插入会出错，如果没有就成功了。</p></li></ol><p>对于已有 <code>id</code> 的数据，举例操作如下：</p><pre><code>mysql&gt; update table_1 set image=&quot;xxx&quot; where id=10;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0</code></pre><p>如果完全添加新数据，举例如下：</p><pre><code>mysql&gt; insert into 表名 （id,address） values (1,&#39;柳州&#39;)</code></pre><h2 id="3-导入导出数据表"><a href="#3-导入导出数据表" class="headerlink" title="3. 导入导出数据表"></a>3. 导入导出数据表</h2><p>这里我使用的是 <strong>MySQL Workbench</strong>，可以直观对 MySQL 数据库进行操作。</p><p>登录时连接项目所在的服务器地址，输入账号密码的登录之后，就可以进行操作了。</p><p>如果需要导入导出数据表，直接选择 <code>Table Data Import Wizard</code> 或者 <code>Table Data Export Wizard</code> 就可以。</p><img src="/img/wizard.png" srcset="/img/loading.gif" width="40%"><p>导出时，根据需要进行相关的设置，比如导出格式选择 <code>csv</code>、<code>JSON</code> 等等，分隔符、文本符号怎么显示等等。</p><p><img src="/img/wizard2.png" srcset="/img/loading.gif" alt="tu"></p><br><p>关于 Mysql 数据库的操作就记录到这里，如果后面遇到新操作，再来这里补充～</p><br><hr><p><strong>参考来源：</strong></p><ul><li><p><em><a href="https://blog.csdn.net/qq_41596568/article/details/88983561" target="_blank" rel="noopener">MySql登陆服务器</a></em></p></li><li><p><em><a href="http://c.biancheng.net/view/2579.html" target="_blank" rel="noopener">MySQL UPDATE：修改数据（更新数据）</a></em></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue 学习笔记】Vue.js 实现在线翻译小项目</title>
    <link href="/2020/05/30/vue%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/05/30/vue%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>用 Vue.js 实现一个在线翻译的小项目。学习课程用半天，课后总结居然用了一天？</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用 Vue 的脚手架工具（CLI）搭建好一套开发环境之后，我跟着一个网上课程学习了如何开发一个简单的在线翻译小项目。</p><p>需要用到的知识点包括：</p><ul><li>使用 <code>@vue/cli</code> 创建项目</li><li>创建多个组件</li><li>组件之间的调用</li><li><code>http</code> 访问请求</li><li>获取在线翻译 API key</li><li>应用 Bootstrap 主题</li></ul><h1 id="一、使用-vue-cli-创建新项目"><a href="#一、使用-vue-cli-创建新项目" class="headerlink" title="一、使用 @vue/cli 创建新项目"></a>一、使用 @vue/cli 创建新项目</h1><p>如何使用 <code>@vue/cli</code> 创建项目，在上一篇文章里已经记录过，这里就不再重复了。这次创建的项目还是在原来的 <code>Projects</code> 文件夹下，项目名称为 <code>my-project</code>。</p><p>需要注意的是，因为上一篇文章中，我已经创建了一个名为 <code>vueapp</code> 的项目，其默认端口为 <code>8080</code>，因此在新的项目创建好之后，需要改变默认的端口号，比如改为 <code>8081</code>。</p><p>端口号需要在配置文件里更改，也就是 <code>/config/inedx.js</code>这个文件：</p><pre><code class="Javascript">// Various Dev Server settingshost: &#39;localhost&#39;, // can be overwritten by process.env.HOSTport: 8081, // can be overwritten by process.env.PORT, if port is in use, a free one will be determinedautoOpenBrowser: false,errorOverlay: true,notifyOnErrors: true,poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</code></pre><p>将 <code>port</code> 后面的的值改为<code>8081</code>，或者任意一个不被占用的端口号。</p><p>配置好之后，在浏览器访问 <code>http://localhost:8081</code>，就能看到 Vue 项目的初始页面了。</p><p><img src="/img/vue_init.png" srcset="/img/loading.gif" alt="init"></p><h1 id="二、创建组件"><a href="#二、创建组件" class="headerlink" title="二、创建组件"></a>二、创建组件</h1><p>将原模版中默认的内容删掉，重新创建我们需要的内容。</p><p>此次想要创建的在线翻译项目，包括三个部分：</p><ol><li>主组件（App.vue），用来显示页面标题</li><li>Form 组件（TranslateForm.vue），用来创建翻译词条输入，语言筛选框，以及搜索按钮</li><li>Ouutput 组件（TranslateOutput.vue），用来展示在线翻译的结果</li></ol><h2 id="1-创建组件并引入"><a href="#1-创建组件并引入" class="headerlink" title="1. 创建组件并引入"></a>1. 创建组件并引入</h2><p>话不多说，先在 <code>/components</code> 目录下创建两个组件 <code>TranslateForm.vue</code> 和 <code>TranslateOutput.vue</code>。并填充好每个组件中的基本代码结构。</p><p>以 <code>TranslateForm.vue</code> 为例：</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;translateForm&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  // 输出 name 到 App.vue  export default {    name: &quot;translateForm&quot;,  };&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>在这个组件中，定义好 <code>translateForm</code> 的 <code>id</code> 和要输出的 <code>name</code>，这样就可以在 <code>App.vue</code> 中引入， <code>TranslateOutput.vue</code> 组件同理。如果是小的组件，CSS 相关的的代码可以直接写到 <code>&lt;style&gt;</code> 标签中。</p><p>组件创建好之后，就可以在 <code>App.vue</code> 中引入两个组件：</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!-- 引入两个组件 --&gt;    &lt;translateForm&gt;&lt;/translateForm&gt;    &lt;translateOutput&gt;&lt;/translateOutput&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  // import components  import TranslateForm from &quot;./components/TranslateForm&quot;;  import TranslateOutput from &quot;./components/TranslateOutput&quot;;  export default {    name: &quot;App&quot;,    // import components    components: {      TranslateForm,      TranslateOutput,    },  };&lt;/script&gt;&lt;style&gt;  #app {    font-family: &quot;Avenir&quot;, Helvetica, Arial, sans-serif;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;    text-align: center;    color: #2c3e50;    margin-top: 60px;  }&lt;/style&gt;</code></pre><p>引入的位置有三个，一个在 <code>&lt;template&gt;</code> 中，一个在 <code>import</code> 中，一个在 <code>export default</code> 中的 <code>components</code> 中。</p><p><strong>需要注意的是，两个位置引入的组件名称是两个 <code>.vue</code> 文件的名称，并非组件里定义的 <code>name</code>。在这里，<code>.vue</code> 文件的名称首字母都是大写，而 <code>name</code> 中的第一个首字母是小写，注意区分。</strong></p><h2 id="2-填充页面的基本内容"><a href="#2-填充页面的基本内容" class="headerlink" title="2. 填充页面的基本内容"></a>2. 填充页面的基本内容</h2><p>接下来，我们先填充主页面的基本内容。在 <code>App.vue</code> 中，填充页面的标题和副标题：</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;在线翻译&lt;/h1&gt;    &lt;h5&gt;简单 / 易用 / 便捷&lt;/h5&gt;    &lt;!-- 引入两个组件 --&gt;    &lt;translateForm&gt;&lt;/translateForm&gt;    &lt;translateOutput&gt;&lt;/translateOutput&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>在 <code>TranslateForm.vue</code> 中填充输入框、筛选框和“翻译”按钮：</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;translateForm&quot;&gt;    &lt;div&gt;      &lt;form&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;输入需要翻译的内容&quot; /&gt;        &lt;select&gt;          &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;          &lt;option value=&quot;ru&quot;&gt;Russian&lt;/option&gt;          &lt;option value=&quot;kor&quot;&gt;Korean&lt;/option&gt;          &lt;option value=&quot;jp&quot;&gt;Japanese&lt;/option&gt;        &lt;/select&gt;        &lt;input type=&quot;submit&quot; value=&quot;翻译&quot; /&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>此时，就可以在页面中看到填充的基本信息：</p><img src="/img/基本页面.png" srcset="/img/loading.gif" width="30%"><h2 id="3-定义事件"><a href="#3-定义事件" class="headerlink" title="3. 定义事件"></a>3. 定义事件</h2><p>接下来，我们需要定义几个事件。</p><p>首先，需要获取用户在 <code>&lt;input&gt;</code> 标签中输入的值，在点击“翻译”按钮时，先 <code>alert</code> 一下输入的值。</p><p>分步来做：</p><ol><li>使“翻译”按钮生效</li><li>获取 <code>&lt;input&gt;</code> 标签的值，并 <code>alert</code> 出来</li></ol><p>给 <code>&lt;form&gt;</code> 标签定义一个点击提交事件 <code>v-on:submit=&quot;formSubmit&quot;</code>，然后在 JS 部分中定义一个 <code>method</code>方法，实现<code>formSubmit</code> 的功能，此时点击“翻译”按钮，页面会弹出 <code>alert</code> 定义的文字 “hello world”。</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;translateForm&quot;&gt;    &lt;div&gt;      &lt;form v-on:submit=&quot;formSubmit&quot;&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;输入需要翻译的内容&quot; /&gt;        &lt;select v-model=&quot;language&quot;&gt;          &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;          &lt;option value=&quot;ru&quot;&gt;Russian&lt;/option&gt;          &lt;option value=&quot;kor&quot;&gt;Korean&lt;/option&gt;          &lt;option value=&quot;jp&quot;&gt;Japanese&lt;/option&gt;        &lt;/select&gt;        &lt;input type=&quot;submit&quot; value=&quot;翻译&quot; /&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &quot;translateForm&quot;,    methods: {      formSubmit: function () {        alert(&quot;hello world&quot;);      },    },  };&lt;/script&gt;</code></pre><p>接下来，需要获取 <code>&lt;input&gt;</code> 标签的值，并 <code>alert</code> 出来，此时涉及到数据绑定。在 JS 中添加<code>data</code>方法，在这个方法中定义一个属性，然后使用 <code>v-model</code> 将<code>&lt;input&gt;</code> 的值绑定到这个属性上。</p><p>这个属性我命名为 <code>textToTranslate</code>，默认给一个空值：</p><pre><code class="html">&lt;script&gt;  export default {    name: &#39;translateForm&#39;,    data: function() {        return {            // 定义绑定到 &lt;input&gt; 标签中的属性            textToTranslate: &quot;&quot;        }    }，    methods: {        formSubmit:function(){            alert(&quot;hello world&quot;);        }    }  }&lt;/script&gt;</code></pre><p>之后，将 <code>textToTranslate</code> 属性绑定到 <code>&lt;input&gt;</code> 标签中。这时，当用户输入内容，并点击“翻译”按钮时，就可以在 <code>method</code> 方法中 <code>alert</code> 出用户输入的内容，也就是传递到 <code>textToTranslate</code> 中的值：</p><pre><code class="html">&lt;input type=&quot;text&quot; v-model=&quot;textToTranslate&quot; placeholder=&quot;输入需要翻译的内容&quot; /&gt;</code></pre><pre><code class="javascript">methods: {      formSubmit:function(){          alert(this.textToTranslate);      }  }</code></pre><p>这个时候，页面会有一次自动刷新，需要把页面自动刷新关掉（取消默认事件）：</p><pre><code class="javascript">methods: {      formSubmit:function(e){          alert(this.textToTranslate);          // 取消默认事件          e.preventDefault();      }  }</code></pre><h2 id="4-传递输入内容至根组件"><a href="#4-传递输入内容至根组件" class="headerlink" title="4. 传递输入内容至根组件"></a>4. 传递输入内容至根组件</h2><p><code>TranslateForm.vue</code> 组件中获取到的输入内容，<strong>需要传递到根组件 <code>App.vue</code>，在根组件中将输入内容进行翻译，再将翻译结果传递给 <code>TranslateOutput.vue</code> 组件，然后显示出来。</strong></p><p>那么，怎么样才能把 <code>TranslateForm.vue</code> 组件中的内容传递给根组件（父组件）？</p><p>Vue 中提供了一个“事件注册”的方法，实现子组件向父组件传值：</p><pre><code class="javascript">//第一个参数是注册事件的名称，名字随便起，第二参数是要传的值this.$emit(&quot;事件名称&quot;, &quot;要传递的值&quot;);</code></pre><p><code>TranslateForm.vue</code> 组件中，在 <code>method</code> 方法里注册一个事件 <code>formSubmitted</code>，传递的值就是 <code>this.textToTranslate</code>：</p><pre><code class="javascript">methods: {     formSubmit:function(e){         // alert(this.textToTranslate);         // 注册事件，传递输入的值给根组件         this.$emit(&quot;formSubmitted&quot;, this.textToTranslate);         // 取消默认事件         e.preventDefault();     } }</code></pre><p>定义好之后，在 <code>App.vue</code> 中的相应位置来接收，将接收的事件定义为 <code>translateText</code>：</p><pre><code class="html">&lt;translateForm v-on:formSubmitted=&quot;translateText&quot;&gt;&lt;/translateForm&gt;...&lt;script&gt;  methods: {      // 定义一个参数 text，来接收子组件传递过来的值      translateText: function(text) {          alert(text);      }  }&lt;/script&gt;</code></pre><p>这样，组件之间的传值问题就解决了。</p><h2 id="5-调用百度翻译-API-实现翻译"><a href="#5-调用百度翻译-API-实现翻译" class="headerlink" title="5. 调用百度翻译 API 实现翻译"></a>5. 调用百度翻译 API 实现翻译</h2><p>传递到跟组件的值，将借助百度翻译 API 来进行翻译。目前百度翻译提供免费的通用型 API，普通开发者可以直接申请 API key，调用限制为 1s 一次，对于这个小项目够用了。</p><p><strong>通用翻译 API HTTP 地址：</strong></p><ul><li><a href="http://api.fanyi.baidu.com/api/trans/vip/translate" target="_blank" rel="noopener">http://api.fanyi.baidu.com/api/trans/vip/translate</a></li></ul><p>在此链接基础上，需要输入多个参数构成 API 的访问地址。为了保证调用安全，百度翻译 API 采用了生成签名的方式（md5 加密），具体生成方法在官方文档中有详细的举例。</p><p><img src="/img/baiduapi.png" srcset="/img/loading.gif" alt="api"></p><p>Javascript 中实现 md5 加密需要借助插件 <code>js-md5</code>：</p><pre><code class="terminal">npm install --save js-md5</code></pre><p>下载之后，需要在 <code>main.js</code> 文件中引入：</p><pre><code class="javascript">import md5 from &quot;js-md5&quot;;Vue.prototype.$md5 = md5;</code></pre><p>然后在 <code>App.vue</code> 中使用：</p><pre><code class="javascript">// 按官方文档中的 step 1 生成拼接字符串，并存储到变量中var baiduApi = xxxxxx;// 将拼接字符串进行 md5 加密var md5 = this.$md5(baiduApi);</code></pre><h2 id="6-http-方法与-jsonp-方法"><a href="#6-http-方法与-jsonp-方法" class="headerlink" title="6. $http 方法与 $jsonp 方法"></a>6. <code>$http</code> 方法与 <code>$jsonp</code> 方法</h2><p>在 Vue 项目中调用 API，可以使用 <code>http</code> 方式调用，也可以使用 <code>jsonp</code>，我们先使用前者。使用 <code>http</code> 调用，需要从项目所在目录安装 <code>vue-resource</code>:</p><pre><code>npm install vue-resource --save</code></pre><p>安装好之后，在 <code>main.js</code> 中引入：</p><pre><code>import VueResource from &#39;vue-resource&#39;// 使用中间件Vue.use(VueResource)</code></pre><p>引入成功，回到 <code>App.vue</code> ，将 method 方法中的代码做相应改变，使用 <code>http</code> 请求，然后返回请求结果：</p><pre><code class="javascript">&lt;script&gt;methods: {    // 定义一个参数 text，来接收子组件传递过来的值    translateText: function(text) {        // alert(text);        this.$http.get(&#39;http://api.fanyi.baidu.com/api/trans/vip/translate?q=&#39; + text + &#39;&amp;from=zh&amp;to=en&amp;appid=xxxx&amp;salt=1435660288&amp;sign=&#39; + md5)            // 返回请求结果 response            .then((response)=&gt;{                // 打印请求结果                console.log(response);            })    }}&lt;/script&gt;</code></pre><p>重新运行项目出现了 <code>No &#39;Access-Control-Allow-Origin&#39;</code> 错误，产生了跨域的问题。我没有找到基于 <code>$http</code> 请求的跨域问题解决办法，于是又尝试了第二种方法：使用 <code>jsonp</code> 进行 API 请求。</p><ul><li><p>同样，也需要先在项目目录下安装 <code>jsonp</code> 模块：<code>npm install vue-jsonp --save</code>；</p></li><li><p>在 <code>main.js</code> 中引入该模块</p></li></ul><pre><code>import VueJsonp from &#39;vue-jsonp&#39;// 使用中间件Vue.use(VueJsonp)</code></pre><p>引入之后，就可以在 <code>App.vue</code> 中使用 <code>jsonp</code> 进行跨域请求数据：</p><pre><code class="javascript">var param = {  header: {    &quot;content-type&quot;: &quot;application/xml&quot;,  },};// jsonp 解决跨域问题this.$jsonp(  &quot;http://api.fanyi.baidu.com/api/trans/vip/translate?q=&quot; +    text +    &quot;&amp;from=zh&amp;to=en&amp;appid=xxx&amp;salt=1435660288&amp;sign=&quot; +    md5,  param).then((response) =&gt; {  console.log(response.trans_result[0].dst);});</code></pre><p>此时就可以获取到 JSON 数据了，我只需要翻译后的内容，也就是 <code>response.trans_result</code> 中的内容，根据 JSON 的结构来准确定位。</p><h1 id="三、传递翻译结果到-TranslateOutput-vue-组件中"><a href="#三、传递翻译结果到-TranslateOutput-vue-组件中" class="headerlink" title="三、传递翻译结果到 TranslateOutput.vue 组件中"></a>三、传递翻译结果到 <code>TranslateOutput.vue</code> 组件中</h1><p>拿到翻译结果之后，接下来就需要传递给 <code>TranslateOutput.vue</code> 组件，在这个组件中显示。</p><p>在 <code>App.vue</code> 中写一个 <code>data</code> 方法，在这个方法中定义一个属性 <code>translatedText</code>，将其设置为空值，然后将 API 请求的结果存储到 <code>translatedText</code> 当中：</p><pre><code class="javascript">data: function() {    return {      translatedText: &quot;&quot;    }  }...// jsonp 解决跨域问题this.$jsonp(&#39;http://api.fanyi.baidu.com/api/trans/vip/translate?q=&#39; + text                + &#39;&amp;from=zh&amp;to=en&amp;appid=xxx&amp;salt=1435660288&amp;sign=&#39; + md5, param)    .then((response)=&gt;{    // console.log(response.trans_result[0].dst);    // 将结果赋值给 translatedText    this.translatedText = response.trans_result[0].dst    })</code></pre><p>并且在 html 的部分绑定这个属性：</p><pre><code>&lt;translateOutput v-text=&quot;translatedText&quot;&gt;&lt;/translateOutput&gt;</code></pre><p>然后，在 <code>TranslateOutput.vue</code> 中实现 <code>translatedText</code> 这个属性：</p><pre><code>export default {  name: &#39;translateOutput&#39;,  props: [      &quot;translatedText&quot;  ]}</code></pre><p>同时，需要在 html 的部分调用这个属性：</p><pre><code>&lt;template&gt;  &lt;div id=&quot;translateOutput&quot;&gt;    &lt;h2&gt;{{translatedText}}&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>到这里，在线翻译小项目的基本功能就实现的差不多了。</p><h2 id="实现多语种翻译"><a href="#实现多语种翻译" class="headerlink" title="实现多语种翻译"></a>实现多语种翻译</h2><p>上面的翻译结果都是基于英文的，要实现多语言的翻译，还需要在 <code>TranslateForm.vue</code> 组件里添加多个语言的选项：</p><pre><code class="html">&lt;select&gt;  &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;  &lt;option value=&quot;ru&quot;&gt;Russian&lt;/option&gt;  &lt;option value=&quot;kor&quot;&gt;Korean&lt;/option&gt;  &lt;option value=&quot;jp&quot;&gt;Japanese&lt;/option&gt;&lt;/select&gt;</code></pre><p>其中的 <code>value</code> 属性按照百度翻译 API 文档中的规定来写。</p><p>在 <code>&lt;select&gt;</code> 标签中定义一个名为 <code>language</code> 的属性，相应的属性在 <code>data</code> 方法中：</p><pre><code>&lt;select v-model=&quot;language&quot;&gt;&lt;script&gt;data: function() {      return {          textToTranslate: &quot;&quot;,          language: &quot;&quot;      }  }  &lt;/script&gt;</code></pre><p><code>language</code> 属性定义好之后，需要将用户选择的 <code>language</code> 的值传递给根组件，以便在根组件的 API 请求中对应翻译的语种。实现方式同样借助 <code>$emit()</code> 注册事件，只需要在原来的注册事件中增加 <code>language</code> 的值：</p><pre><code class="javascript">// 注册事件this.$emit(&quot;formSubmitted&quot;, this.textToTranslate, this.language);</code></pre><p>在 <code>App.vue</code> 中，用一个参数 <code>langage</code> 接收子组件传递过来的值，与前一个参数 <code>text</code> 是一样的逻辑。再将原 API 地址中的 <code>en</code> 替换为 <code>language</code>：</p><pre><code class="javascript">methods: {    translateText: function(text, language) {        // API请求部分    }</code></pre><p>这样，多语言翻译就实现了。</p><p>不过，刷新页面之后，语言选项是空白，没有指定默认的选项。此时，可以通过添加 <code>created</code> 方法（该方法自动执行），来设置默认显示的选项：</p><pre><code>export default {  name: &#39;translateForm&#39;,  ...  created: function() {      this.language = &quot;en&quot;;  }}</code></pre><h1 id="四、应用-Bootstrap-主题更改页面样式"><a href="#四、应用-Bootstrap-主题更改页面样式" class="headerlink" title="四、应用 Bootstrap 主题更改页面样式"></a>四、应用 Bootstrap 主题更改页面样式</h1><p>可以直接在 Bootswatch 这个网站上，下载想要的主题包，然后将包文件放到 <code>/static/css/</code> 的路径下，并在 <code>index.html</code> 文件中引入：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/bootstrap.min.css&quot;&gt;</code></pre><p>更改根组件的一些样式，为副标题添加一个强调色：</p><pre><code>&lt;h5 class=&quot;text-muted&quot;&gt;这是一个很小的 Vue 项目 😊&lt;/h5&gt;</code></pre><p>更改 <code>TranslateForm.vue</code> 组件的一些样式：</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;row&quot; id=&quot;translateForm&quot;&gt;    &lt;div class=&quot;offset-md-3 col-md-6&quot;&gt;      &lt;form id=&quot;transForm&quot; class=&quot;well form-inline&quot; v-on:submit=&quot;formSubmit&quot;&gt;        &lt;input          class=&quot;form-control col-md-8&quot;          type=&quot;text&quot;          v-model=&quot;textToTranslate&quot;          placeholder=&quot;输入需要翻译的内容&quot;        /&gt;        &lt;select class=&quot;form-control col-md-2&quot; v-model=&quot;language&quot;&gt;          &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;          &lt;option value=&quot;ru&quot;&gt;Russian&lt;/option&gt;          &lt;option value=&quot;kor&quot;&gt;Korean&lt;/option&gt;          &lt;option value=&quot;jp&quot;&gt;Japanese&lt;/option&gt;        &lt;/select&gt;        &lt;input class=&quot;btn btn-primary  col-md-2&quot; type=&quot;submit&quot; value=&quot;翻译&quot; /&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><code>offset-md-3 col-md-6</code> 这个属性是 Bootstrap 4 中的写法，和较早版本的写法稍有不同，需要注意一下。</p><p>还有一些样式，就直接在 <code>&lt;style&gt;</code> 标签里写了，比如添加边框，设置边框样式和颜色等等。</p><p><code>TranslateOutput.vue</code> 组件中输入结果的字体不够明显，也可以直接在 <code>&lt;style&gt;</code> 标签里添加一些针对字体的样式。</p><p><strong>最终，这个在线翻译小项目的页面就是这个样子啦：</strong></p><p><img src="/img/final-translate.png" srcset="/img/loading.gif" alt=""></p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="http://api.fanyi.baidu.com/product/113" target="_blank" rel="noopener">百度翻译开放平台</a></em></li><li><em><a href="https://blog.csdn.net/unbreakablec/article/details/91792652" target="_blank" rel="noopener">js MD5 加密</a></em></li><li><em><a href="https://www.zhihu.com/question/46202188" target="_blank" rel="noopener">Vue.js 如何实现跨域请求？</a></em></li><li><em><a href="https://www.cnblogs.com/wjw1014/p/11592444.html" target="_blank" rel="noopener">vue 使用 jsonp 请求数据</a></em></li><li><em><a href="https://www.csdn.net/gather_20/MtTaAg1sOTA2MS1ibG9n.html" target="_blank" rel="noopener">vue 中的 css 文件位置</a></em></li><li><em><a href="https://bootswatch.com" target="_blank" rel="noopener">Bootswatch</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>百度翻译API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Vue 学习笔记】Vue 安装——使用命令行工具（CLI）脚手架</title>
    <link href="/2020/05/25/vue%E5%AE%89%E8%A3%85/"/>
    <url>/2020/05/25/vue%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习 Vue 的时候，首先要关注的就是安装问题。今天要记录的是通过脚手架创建 Vue 新项目，搭建基本的开发环境。</p></blockquote><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 Vue 的安装，官方文档中提供了几种方法。</p><p>如果是初学者，可以通过<code>npm</code>安装，或者直接在<code>&lt;script&gt;</code>中引入，具体可以参考官方的教程，简单明了。</p><p>这里我使用的是通过 Vue 的 CLI 脚手架工具来构建 Vue 的初始项目，搭建出基本的开发环境，自动配置好目录结构，可以方便的进行本地调试、单元测试、热加载（不重启项目，进行部分代码更新）以及本地部署等。</p><h2 id="Vue-脚手架工具安装"><a href="#Vue-脚手架工具安装" class="headerlink" title="Vue 脚手架工具安装"></a>Vue 脚手架工具安装</h2><p>看网上安装教程的时候发现，之前的脚手架工具 <code>vue-cli</code> 已经更改为 <strong>@vue/cli</strong>，官方教程中的安装方式也做了一些调整。</p><p>如果通过之前的方式（<code>npm install -g vue-cli</code>）安装了 <code>vue-cli</code>，需要先进行卸载（<code>npm unistall vue-cli</code>），然后采用新的安装包名称<code>@vue/cli</code>：</p><pre><code>进入项目目录全局安装npm install -g @vue/cli</code></pre><p>回车，输入密码（密闻模式）。</p><p>此时会提醒<code>File exists...Remove the existing file and try again, or run npm with --force to overwrite files recklessly.</code>，是之前安装过 <code>vue-cli</code> 留下的一些文件。</p><p>如果不再需要，就强制覆盖掉：</p><pre><code>npm install -g @vue/cli --force</code></pre><p>安装成功，会显示 <code>@vue/cli</code> 以及一些依赖包的版本：</p><p><img src="/img/vue0525.png" srcset="/img/loading.gif" alt="screenshot"></p><br><h2 id="基于-Webpack-模版-init-初始化项目"><a href="#基于-Webpack-模版-init-初始化项目" class="headerlink" title="基于 Webpack 模版 init 初始化项目"></a>基于 Webpack 模版 init 初始化项目</h2><p>在项目目录下，创建一个基于 Webpack 模版的新项目。</p><p>之前的方式是执行命令：<code>vue init webpack projectname</code>，但是使用 <code>@vue/cli</code> 之后，需要先安装 <code>@vue/cli-init</code>，再进行初始化。</p><p>我创建的项目名称为 <code>vueapp</code>。</p><pre><code>全局安装npm install -g @vue/cli-init再运行vue init webpack vueapp</code></pre><p>回车之后，会要求填写相应的信息：</p><pre><code>? Project name vueapp? Project description A Vue.js project? Author sharonsss? Vue build standalone? Install vue-router? No? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) npm   vue-cli · Generated &quot;vueapp&quot;.</code></pre><p>初建项目的时候可以都默认，需要 install 的部分先选择不安装，后面再说。</p><p>最后一项会询问是否在创建了新项目之后自动安装依赖，默认选择“是”。不然也得自己手动执行安装。</p><pre><code># Installing project dependencies ...# ========================......# Project initialization finished!# ========================To get started:  cd vueapp  npm run devDocumentation can be found at https://vuejs-templates.github.io/webpack</code></pre><p>依赖安装完成之后，会提示你如何启动项目。</p><p>执行 <code>npm run dev</code>，在浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，就能看到新项目初始化的页面啦。（8080 为默认端口，如果该端口被占用，可以修改为其他的端口）</p><p>也就是这个页面：</p><p><img src="/img/vue_init.png" srcset="/img/loading.gif" alt=" "></p><p>此时，<code>vueapp</code> 项目路径下的目录是这个样子：</p><p><img src="/img/vue_folder.png" srcset="/img/loading.gif" alt="folder"></p><ul><li><p>具体的项目开发，都是在 <code>src</code> 目录中进行的。</p></li><li><p><code>build</code>和<code>config</code>目录是和 webpack 配置相关的.</p></li><li><p><code>node_modules</code> 是我们通过 <code>npm install</code> 安装的依赖。</p></li></ul><p>这样 <code>@vue/cli</code> 脚手架工具就成功安装了，接下来就可以在模版的基础上进行自己的 Vue 项目开发了。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 程序打包之后，替换 jar 包内的文件</title>
    <link href="/2020/04/30/430/"/>
    <url>/2020/04/30/430/</url>
    
    <content type="html"><![CDATA[<p><strong>Java 对我来说绝对是一窍不通，基本陌生。</strong></p><a id="more"></a><p>奈何公司的工程师小伙伴开发了一个 Java 程序，前端、后端、数据库都是他自己一个人一手搭建起来的，遇到任何问题也只有他才能解决。</p><p>这两天领导一句话，要求把程序里的 Logo 换掉，可是小伙伴的程序都是打包好的，jar 包里的文件，怎么样替换呢？</p><p>小伙伴也不知道，这种不能像拆口袋一样，直接拆包替换东西。</p><p>下载到本地，在压缩软件里，不解压的情况下直接替换里面的 logo 文件，再上传到服务器？</p><p><strong>尝试失败。</strong></p><p>文件在压缩包里替换成功，但上传到服务器，替换原 jar 包之后，运行程序会报错，显示修改打包文件错误。</p><p>看来不能直接这样替换文件？！</p><p><img src="/img/wunai.jpg" srcset="/img/loading.gif" alt="wunai"></p><p>之后，在万能百度上才找到正确方法：</p><h2 id="替换-jar-包中指定文件"><a href="#替换-jar-包中指定文件" class="headerlink" title="替换 jar 包中指定文件"></a>替换 jar 包中指定文件</h2><ol><li><strong>找到 jar 包中指定文件的路径：</strong></li></ol><p>先进入 jar 包所在的目录下：</p><pre><code>jar -tvf test.jar | grep logo.svg</code></pre><ol start="2"><li><strong>解压指定路径下的文件</strong></li></ol><pre><code>jar -xvf test.jar conf/logo.svg</code></pre><p>会自动在当前路径下创建目录。</p><ol start="3"><li><strong>把需要替换的文件删除</strong></li></ol><pre><code>rm -rf conf/logo.svg</code></pre><ol start="4"><li><strong>上传文件到替换文件的目录下</strong></li></ol><pre><code class="terminal">$ scp 本地目录 服务器目录（绝对路径）</code></pre><ol start="5"><li><strong>更新到 jar 包中</strong></li></ol><pre><code>jar -uvf test.jar conf/logo.svg</code></pre><br><h2 id="2020-05-25-补充"><a href="#2020-05-25-补充" class="headerlink" title="2020.05.25 补充"></a>2020.05.25 补充</h2><p>实操过程中，正确替换了 Jar 包中的文件之后，需要重新启动服务器，然后重新启动 Redis、应用程序、Nginx，不然系统还是运行不起来的。mark 一下。</p><br><h2 id="2020-06-09-补充"><a href="#2020-06-09-补充" class="headerlink" title="2020.06.09 补充"></a>2020.06.09 补充</h2><p>上面记录的太过简单，这里再补充一下当时复制 <code>jar</code> 包到本地时，需要注意的地方。</p><h3 id="1-从远程服务器下载文件到本地电脑"><a href="#1-从远程服务器下载文件到本地电脑" class="headerlink" title="1. 从远程服务器下载文件到本地电脑"></a>1. 从远程服务器下载文件到本地电脑</h3><p>首先，将 <strong>远程服务器(已登陆)</strong> 的文件复制到本地，即将文件下载到 <strong>本地电脑</strong> ，需要使用 <code>scp</code> 命令。</p><p>如果是已经登陆了远程的服务器，相当于远程的服务器是“本地”，而需要下载到的电脑就变成了“远程”。因此，scp 命令中不需要加入远程服务器的用户名和 <code>IP</code>，相反，本机电脑的地址需要加上用户名和 <code>IP</code>：</p><pre><code>scp 已经登陆的远程服务器的绝对路径 username@ip:本机电脑的绝对路径</code></pre><p>第一次尝试的时候，出现了 <strong>本地 ip</strong> <code>connection failed</code> 的错误。网上搜索了半天答案，无解。</p><p>后来意识到，<strong>莫非是电脑远程访问权限的问题？</strong> 于是进到 <code>sharing</code> 里，打开了<strong>远程登录</strong>的权限。</p><p>再次尝试，出现如下提示：</p><pre><code>The authenticity of host &#39;10.xx.xx.xx&#39; can&#39;t be established.ECDSA key fingerprint is xxxxxx.ECDSA key fingerprint is MD5:xxxxx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>这里选择 <code>yes</code>，会出现一条 <code>warning</code> 信息，提示风险。如果是确定的操作，不用理会。</p><p><code>Warning: Permanently added &#39;10.xx.xx.xx&#39; (ECDSA) to the list of known hosts.</code></p><p>然后会要求输入电脑密码，回车，远程服务器上的文件就可以正常下载了。</p><h3 id="2-从本地电脑上传文件至远程服务器"><a href="#2-从本地电脑上传文件至远程服务器" class="headerlink" title="2. 从本地电脑上传文件至远程服务器"></a>2. 从本地电脑上传文件至远程服务器</h3><p>与上面相反，如果要将本地电脑的文件上传到远程服务器，则需要使用命令：</p><pre><code>scp username@ip:本机电脑的绝对路径 已经登陆的远程服务器的绝对路径</code></pre><p>为了防止弄混，需要记住一点：</p><p><code>scp</code> 命令中，第一个路径是 <strong>输出路径</strong>， 第二个路径是 <strong>输入路径</strong>。不管是从远程到本地还是本地到远程，<strong>输入输出的路径顺序是不变的</strong>。</p><p>另外， <code>scp</code> 命令前也不需要加 <code>sudo</code>。</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://blog.csdn.net/u011817217/article/details/92411009" target="_blank" rel="noopener">使用 jar 命令替换 jar 包中指定文件</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java 程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 服务器根目录空间不足与 Nginx 重启</title>
    <link href="/2020/04/24/420/"/>
    <url>/2020/04/24/420/</url>
    
    <content type="html"><![CDATA[<p>近期运营的产品碰到了服务器的问题，断断续续的无法访问，部署在上面的系统也因此500了。对我这个服务器小白来说，感觉坑好多，再加上同事隔离在家，没办法面对面请教解决的办法，着实心塞了一段时间。</p><a id="more"></a><p>还好今天早上试着访问了一下服务器，居然能进去，赶紧找同样来到公司上班的同事，教我如何解决。</p><h1 id="访问-Linux-服务器、暂时解决根目录空间不足的问题"><a href="#访问-Linux-服务器、暂时解决根目录空间不足的问题" class="headerlink" title="访问 Linux 服务器、暂时解决根目录空间不足的问题"></a>访问 Linux 服务器、暂时解决根目录空间不足的问题</h1><p>服务器无法远程访问，核心的问题是（根据公司负责所有服务器运维的同事所说），这台服务器因为“根目录空间不足”，导致 <code>ssh</code> 无法访问，而我们并非运维，都需要 <code>ssh</code> 远程访问。</p><p>服务器的根目录空间不足？？这个问题咋解决，我一脸黑人问号？？</p><p>无奈，今天早晨能访问了之后，我就进去看了一下，进到根目录里 <code>df -hl</code> 得到下面的信息：</p><pre><code>Filesystem                 Size  Used Avail Use% Mounted on/dev/mapper/centos-root     17G   17G    0G 100% /devtmpfs                   7.8G     0  7.8G   0% /devtmpfs                      7.8G     0  7.8G   0% /dev/shmtmpfs                      7.8G  829M  7.0G  11% /runtmpfs                      7.8G     0  7.8G   0% /sys/fs/cgroup/dev/sda1                 1014M  235M  780M  24% /boot/dev/mapper/datavg-datalv  500G  1.1G  499G   1% /datatmpfs                      1.6G  8.0K  1.6G   1% /run/user/42cm_processes               7.8G     0  7.8G   0% /run/cloudera-scm-agent/processtmpfs                      1.6G     0  1.6G   0% /run/user/1000tmpfs                      1.6G   40K  1.6G   1% /run/user/0</code></pre><p><code>/</code> 根目录100%的空间没有一点剩余？？而且下面几项的总和并没有到100%，这是为啥？又是一脸黑人问号。。</p><p>询问我们这个系统部署的同事，说会不会是日志文件占用空间太多，删一删。然而我并不知道是哪个目录里的日志可以删，哪个又不可以。于是只好找来另外一个做大数据的同事（曾经负责过一段时间这个服务器的人），试着看一看。因为这个同事曾经在这台服务器上安装过 hadoop、hive 相关的东西，占用了一些空间（现在已经不用了）。于是一番操作，删掉了相关的 <code>log</code> 文件夹。</p><p>这些文件相关的细节我不是很懂，再加上 linux 服务器的操作，我其实之前也没有太多实操过，所以看着 <code>terminal</code> 里一行一行的数据，略略感觉自己果真是个小白。</p><p>说回来，删掉一部分日志文件之后，释放出来了4.1G的空间，按照比例来说，清掉了24%的空间，可以说是大进步了！</p><pre><code>Filesystem                 Size  Used Avail Use% Mounted on/dev/mapper/centos-root     17G   13G  4.2G  76% /devtmpfs                   7.8G     0  7.8G   0% /devtmpfs                      7.8G     0  7.8G   0% /dev/shmtmpfs                      7.8G  829M  7.0G  11% /runtmpfs                      7.8G     0  7.8G   0% /sys/fs/cgroup/dev/sda1                 1014M  235M  780M  24% /boot/dev/mapper/datavg-datalv  500G  1.1G  499G   1% /datatmpfs                      1.6G  8.0K  1.6G   1% /run/user/42cm_processes               7.8G     0  7.8G   0% /run/cloudera-scm-agent/processtmpfs                      1.6G     0  1.6G   0% /run/user/1000tmpfs                      1.6G   40K  1.6G   1% /run/user/0</code></pre><p>再有一些无用的安装包之类，也是可以删掉的。</p><p>至此，我们的系统目前已经可以访问了。说实话，根目录的空间简直不要太小喔 😓。</p><p>相对根本的解决办法：</p><p><strong>让运维同事看看能否调整根目录的空间，给大点，也有能伸缩的余地。</strong></p><p>PS：</p><p>查看服务器空间的空间目录情况：</p><pre><code>df -h    查看整台服务器的硬盘使用情况df -hl  可以加上参数查看磁盘剩余空间信息cd /    进入根目录cd ..   回到上层目录du -sh *    查看每个文件夹的大小</code></pre><br><h1 id="Nginx-查看进程、重启"><a href="#Nginx-查看进程、重启" class="headerlink" title="Nginx 查看进程、重启"></a>Nginx 查看进程、重启</h1><p>还有一个问题，是 Nginx 会在一些时候 down 掉。</p><p>Nginx 同 Apache 一样都是一种 Web 服务器。官方的说法：</p><blockquote><p>Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、SMTP 代理服务器。Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理进行负载均衡的实现。</p></blockquote><p>我们用 Nginx 主要来做图片服务器，配置图片路径。Nginx down 掉之后，需要重启。经过和部署系统的同事请教之后，在这里记录下。</p><ul><li>首先，进入到系统部署的路径，重启系统。</li></ul><pre><code>[root@bigdata001 dataxx]$sudo XXXReboot.sh</code></pre><ul><li>之后，<code>ps -ef | grep nginx</code> 查询出 Nginx 的主进程号。</li></ul><pre><code>ps -ef | grep nginx</code></pre><ul><li>Kill 查询出的进程号：</li></ul><pre><code>sudo kill -9 进程号</code></pre><ul><li>kill 完进程之后，再次 <code>ps -ef | grep nginx</code> 查询进程号是否已被 kill 掉。若kill 进程时，<code>operation not permitted</code> 则是权限不够，需要前加上 <code>sudo</code>。</li></ul><pre><code>ps -ef | grep nginx</code></pre><ul><li>再然后，cd进入sbin目录    ./nginx nginx 目录，<code>./nginx</code> 重启 nginx。</li></ul><pre><code>./nginx</code></pre><p>做完上面这些，系统就可以正常访问了。</p><p>查了一下原因，可能是服务器本身根目录空间不足之后，Nginx 也被迫中断。</p><p>实操的方法记录在这里，如果以后还出现一样的问题，我也可以找到解决办法。</p><br><p>PS：封面上小企鹅迷人的微笑送给我自己 😂。</p><br>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery、HTML、CSS中的小细节汇总（一）</title>
    <link href="/2020/04/15/0415-1/"/>
    <url>/2020/04/15/0415-1/</url>
    
    <content type="html"><![CDATA[<p>这个博客其中一个目的，是一边开发前端页面，一边记录下自己遇到的问题，很多是非常有tricks的，之后也可能会频繁用到。</p><p>下边主要总结的是 jQuery 和 CSS 中的一些小细节，之后如果积累了更多的点，再补充第二篇。</p><a id="more"></a><br><h1 id="HTML-中获取-lt-span-gt-标签内的值-jQuery"><a href="#HTML-中获取-lt-span-gt-标签内的值-jQuery" class="headerlink" title="HTML 中获取 &lt;span&gt; 标签内的值 - jQuery"></a>HTML 中获取 <code>&lt;span&gt;</code> 标签内的值 - jQuery</h1><p>在 jQuery 中，获取 HTML 中各个标签内值的方法有几个。</p><p>最近遇到了如何获取 <code>&lt;span&gt;</code> 标签内的值的问题，试验了一下几种获取值的方法：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;script language=JavaScript src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;     &lt;span id=&quot;spId&quot;&gt;show me&lt;/span&gt;     &lt;script language=JavaScript&gt;       var test1 = $(&quot;#spId&quot;).val();       var test2 = $(&quot;#spId&quot;).html();       var test3 = $(&quot;#spId&quot;).text();       alert(&quot;val: &quot;  + test1);       alert(&quot;html: &quot; + test2);       alert(&quot;text: &quot; + test3);     &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>三种获取所得的值分别为：</p><pre><code>val: 空html: show metext: show me</code></pre><p>因此，</p><ul><li><p>获取input的信息时，可以用 <code>val()</code></p></li><li><p>获取 <code>&lt;span&gt;</code> 的值，可以用 <code>html()</code> 或者 <code>text()</code></p></li></ul><br><h1 id="CSS-中-active-选择器的用法"><a href="#CSS-中-active-选择器的用法" class="headerlink" title="CSS 中 active 选择器的用法"></a>CSS 中 <code>active</code> 选择器的用法</h1><p>CSS 选择器 <code>active</code> 代表元素被激活（按下）时的样式。“激活”是指从点击模块后直到松开模块的过程。</p><p>例如：</p><pre><code class="css">a:active{  background-color: yellow;}</code></pre><p>来一个简单的实现例子：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;style&gt;      a:active      {        background-color:yellow;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>另外，需要注意一个区别：</strong></p><ul><li><p><code>a.active</code> 是对<code>class=active</code>的<code>a</code>标签生效</p></li><li><p><code>a:active</code> 是对按下的<code>a</code>标签生效</p></li></ul><p>两者所代表的内涵是不一样的。</p><p>此外，<code>active</code> 也可以实现元素 <code>display:none</code> 和 <code>display:block</code> 的切换。</p><br><h1 id="CSS-设置背景、背景图片、blur效果"><a href="#CSS-设置背景、背景图片、blur效果" class="headerlink" title="CSS 设置背景、背景图片、blur效果"></a>CSS 设置背景、背景图片、blur效果</h1><ul><li><p><code>background: url(&#39;url&#39;)</code> 用来设置背景图片，后边可以加 <code>no-repeat</code> 限制是否重复平铺图像</p></li><li><p><code>background-position</code> 和 <code>background-size</code> 用来调整图片的显示方式</p></li></ul><pre><code class="css">.bg {      background: url(&#39;1.jpg&#39;) no-repeat;      height:600px;      width: 100%;      text-align: center;      line-height: 600px;      background-position: center;      background-size: cover;  }</code></pre><ul><li><p>最简单粗暴的设置 blur 的方法，是直接加上 <code>filter: blur(3px)</code> 的属性。但是，这样会导致背景图所在 <code>&lt;div&gt;</code> 内的其他元素，包括文字，都会虚化。解决办法有两种：</p><ul><li><p>第一，将背景图片单独放到一个div里，这样就不会和其他元素的效果有冲突</p></li><li><p>第二，通过 <code>:before</code> 的状态和 <code>z-index</code> 来控制，只让背景图片虚化。举个例子：</p></li></ul></li></ul><pre><code class="css">.demo1{    width: 500px;    height: 300px;    line-height: 50px;    text-align: center;}.demo1:before{    background: url(http://csssecrets.io/images/tiger.jpg) no-repeat;    background-size: cover;    width: 500px;    height: 300px;    content: &quot;&quot;;    position: absolute;    top: 0;    left: 0;    z-index: -1;/*-1 可以当背景*/    -webkit-filter: blur(3px);    filter: blur(3px);}&lt;div class=&quot;demo1&quot;&gt;背景图半透明，文字不透明&lt;br/&gt;  方法：背景图+ filter：blur&lt;/div&gt;</code></pre><p>这种设置可以在不改变div结构的情况下，使背景图片虚化。</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://blog.csdn.net/qq_37540004/article/details/78280454" target="_blank" rel="noopener">css实现 display: none和display: block的切换动画</a></em></li><li><em><a href="https://blog.csdn.net/xiaoxiao20121314/article/details/81103500" target="_blank" rel="noopener">CSS样式的状态hover、focus、active、link、visited详解</a></em></li><li><em><a href="https://www.jianshu.com/p/12a938e5c557" target="_blank" rel="noopener">CSS实现背景图片透明和文字不透明效果</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery需要注意的几个小点</title>
    <link href="/2020/04/11/jquery/"/>
    <url>/2020/04/11/jquery/</url>
    
    <content type="html"><![CDATA[<p>最近在写一个前端的搜索页面，主要思路是从Elasticsearch拿到数据，并在前端做搜索查询的极简页面。ES有提供现成的Javascript API，既有后端Node.js的版本，也有直接从client端就可以获取数据对的接口。<a id="more"></a></p><p>我这次最开始用的是基于Client端直接获取数据的版本。（因为Node.js传参我还搞不太清楚。。）</p><p>前端的实现主要基于原生JavaScript和jQuery，记录下遇到的一些问题。</p><h2 id="1-jQuery-引用链接的位置"><a href="#1-jQuery-引用链接的位置" class="headerlink" title="1. jQuery 引用链接的位置"></a>1. jQuery 引用链接的位置</h2><p>jQuery在html文件中引用的<code>&lt;script&gt;</code>位置，要放到<code>&lt;body&gt;</code>标签之后，如果放到<code>&lt;body&gt;</code>标签之前，运行的时候会报错。</p><h2 id="2-lt-form-action-quot-quot-gt-元素"><a href="#2-lt-form-action-quot-quot-gt-元素" class="headerlink" title="2. &lt;form action=&quot;#&quot;&gt; 元素"></a>2. <code>&lt;form action=&quot;#&quot;&gt;</code> 元素</h2><p><code>&lt;form&gt;</code>标签提供了一个<code>action</code>的属性，这个属性的作用是，点击按钮会刷新页面。</p><p>我的页面中写了一个搜索按钮，按钮包含在<code>&lt;form&gt;</code>标签中，于是导致每次我点击“搜索”的时候，页面都会刷新，去掉这个属性就好。</p><h2 id="3-用-jQuery-判定输入的字符是中文还是英文"><a href="#3-用-jQuery-判定输入的字符是中文还是英文" class="headerlink" title="3. 用 jQuery 判定输入的字符是中文还是英文"></a>3. 用 jQuery 判定输入的字符是中文还是英文</h2><p>思路是用正则表达式来识别，同时利用jQuery的<code>.test()</code>方法。基本的正则表达式还要再复习一下。</p><p>判断字符是否为全英文：</p><pre><code class="Javascript">// 判断输入是否为全英文var re=/^[a-zA-Z]+$/;//判断是否包含数字字母下划线  当使用这个时如果只有部分是中文字符还可以使用英文字体var reg=/[A-Za-z]*[a-z0-9_-]|\s$/;if(!re.test(txt)){    return false;}return true;</code></pre><p>判断输入是否为全中文：</p><pre><code class="Javascript">// 判断输入是否为全中文var res=/^[\u4e00-\u9fa5]+$/;if(!res.test(txt)){    return false;}return true;</code></pre><p>我涉及到的字符输入除了英文就是中文，还有少部分的数字，因此先判定英文字符，如果不是英文，那么就是中文或数字了，规则比较简单。</p><h2 id="4-JS-里的-forEach-和-jQuery-里的-each"><a href="#4-JS-里的-forEach-和-jQuery-里的-each" class="headerlink" title="4. JS 里的 forEach() 和 jQuery 里的 each()"></a>4. JS 里的 forEach() 和 jQuery 里的 each()</h2><p>如果参数为一个，这一个参数代表“元素”。JS举例：</p><pre><code class="JavaScript">var arr = new Array([&quot;b&quot;, 2, &quot;a&quot;, 4],[&quot;c&quot;,3,&quot;d&quot;,6]);arr.forEach(function(item){    alert(item);  //b, 2, a, 4和c,3,d,6});</code></pre><p>如果forEach里有两个参数，则第一个参数为该集合里的元素，第二个参数为集合的索引：</p><pre><code class="Javascript">arr.forEach(function(item, i){}</code></pre><p>但是在jQuery中，如果至哟耦哦一个参数，那么这个参数代表“索引”。举例：</p><pre><code class="Javascript">var arr = new Array([&quot;b&quot;, 2, &quot;a&quot;, 4],[&quot;c&quot;,3,&quot;d&quot;,6]);$.each(arr, function(item){    alert(item);  //0;1});</code></pre><p>如果有两个参数，则第一个为索引，第二个该集合里的元素:</p><pre><code class="Javascript">$.each(arr, function(i, item){}</code></pre><h2 id="5-Bootstrap3-typeahead-js-输入框自动补全"><a href="#5-Bootstrap3-typeahead-js-输入框自动补全" class="headerlink" title="5. Bootstrap3-typeahead.js 输入框自动补全"></a>5. Bootstrap3-typeahead.js 输入框自动补全</h2><p>这次做搜索页面，一个重要的功能是允许用户在搜索时，能出现模糊匹配的词汇（中文和英文），于是用了 bootstrap3-typeahead.js 这个插件。</p><p>typeahead的基本逻辑也很简单，通过访问数据库获取JSON数据之后，利用现成的<code>process()</code>函数就可以自动把获取到的数据显示在搜索框中。</p><p>需要注意的是获取的JSON格式，如果数据结构不符合，需要稍微做一些处理，再输入到<code>process</code>函数中。另外，下载的bootstrap3-typeahead.js 在引用时，注意要放到jQuery文件的后面，不然无法调用。</p><p>实现的效果也比较简单，如果有现成的数组，好说：</p><pre><code class="Javascript">$(function () {            var localArrayData = [&#39;beijing&#39;, &#39;shanghai&#39;, &#39;guangzhou&#39;, &#39;tianjin&#39;, &#39;hangzhou&#39;, &#39;ningbo&#39;];            $(&quot;#txtUser&quot;).typeahead({                source: localArrayData            });        });</code></pre><p>这里的<code>source</code>，就是获取到的数据。</p><p>如果是需要调取数据库的数据，<code>typeahead()</code>方法中，要包含参数为<code>query, process</code>的函数，用来获取数据，并通过<code>process()</code>显示出来。</p><p>以ajax为例：</p><pre><code class="Javascript"> $(function () {            $(&quot;#txtUser&quot;).typeahead({                source: function (query, process) {                    $.ajax({                        url: &#39;/Tools/GetOperUsers&#39;,                        data: {                            name: query                        },                        type: &#39;post&#39;,                        dataType: &quot;json&quot;,                        success: function (data) {                            var res = [];                            $.each(data, function (i, item) {                                var aItem = { id: item.CreateUserId, name: item.CreateUserRealName };//把后台传回来的数据处理成带name形式                                res.push(aItem);                            })                            // res 是我们获取到的数据                            return process(res);                        }                    });                }            });        });</code></pre><p>ES 数据库的数据调取稍有不同，同样参照 client 端的 JS API。</p><p>我在前端实现之后是这样的：</p><p><img src="/img/typeahead.png" srcset="/img/loading.gif" alt="1"></p><p>效果很简单了。</p><p>后边想自定义调整一下显示栏的样式，如果实现了再补充。</p><h2 id="6-文本框刷新之后，清除原来的输入"><a href="#6-文本框刷新之后，清除原来的输入" class="headerlink" title="6. 文本框刷新之后，清除原来的输入"></a>6. 文本框刷新之后，清除原来的输入</h2><p>这个点解决起来不要太简单!</p><p>只需要在<code>&lt;input&gt;</code>文本输入框中加一条属性<code>autocomplete=&quot;off&quot;</code>，就好了。。</p><p>作用域不只是 <code>&lt;input&gt;</code> 标签，<code>&lt;form&gt;</code> 标签同样可以。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch + Kibana 安装记录</title>
    <link href="/2020/04/05/elasticsearch%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/05/elasticsearch%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>公司今年的项目要把原来的数据迁移到Elasticsearch数据库中，通过技术负责人的介绍，我才知道了ES+kibana这个组合，开源，可以基于ES数据直接在Kibana上进行数据查询和图表分析。<a id="more"></a> 想我们之前还苦哈哈的自己写Echarts做数据图表，虽然实现了我们最初的需求，但是和采用Kibana比起来，还是占用了不少的时间和精力。</p><p>这几天在本地搭建了ES+Kibana，在此记录一下。</p><h1 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h1><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>Elasticsearch的安装方式相对来说比较简单。<code>brew</code>的安装方式对我来说太慢，于是直接在官网上下载的安装包（公司网太慢，下个安装包还花了一天时间）。</p><ul><li><p>下载地址：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p></li><li><p>安装版本：7.6.2 （与Kibana的版本要一致）</p></li></ul><p>下载完成之后，放到<code>/usr/local/Cellar/</code>路径下，解压。</p><p>进入 bin 目录启动 ES 并在运行：</p><pre><code>$ ./elasticsearch$ ./elasticsearch -d (后台运行)</code></pre><p>curl 测试是否正常运行（或者在浏览器中打开）：</p><pre><code>$ curl 127.0.0.1:9200</code></pre><p>此时出现：</p><pre><code>{  &quot;name&quot; : &quot;mvQoSGm&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;4vUSt2_AQFSj5LZDVgR74g&quot;,  &quot;version&quot; : {    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;04711c2&quot;,    &quot;build_date&quot; : &quot;2020-04-02T13:34:09.098244Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;7.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.6.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0&quot;  },  &quot;tagline&quot; : &quot;You Know, for Search&quot;</code></pre><p>表示安装成功。</p><p>初步安装之后，我并没有做其他的设置，还有一些插件因为下载路径实在太慢，准备后面再慢慢安装。</p><h2 id="查看ES集群的简单命令"><a href="#查看ES集群的简单命令" class="headerlink" title="查看ES集群的简单命令"></a>查看ES集群的简单命令</h2><h3 id="1-查看集群的健康状态"><a href="#1-查看集群的健康状态" class="headerlink" title="1. 查看集群的健康状态"></a>1. 查看集群的健康状态</h3><pre><code>http://127.0.0.1:9200/_cat/health?v</code></pre><p>URL中_cat表示查看信息，health表明返回的信息为集群健康信息，?v表示返回的信息加上头信息，跟返回JSON信息加上?。</p><ul><li><p>集群的状态（status）：red红表示集群不可用，有故障。yellow黄表示集群不可靠但可用，一般单节点时就是此状态。green正常状态，表示集群一切正常。</p></li><li><p>节点数（node.total）：节点数，这里是2，表示该集群有两个节点。</p></li><li><p>数据节点数（node.data）：存储数据的节点数，这里是2。数据节点在Elasticsearch概念介绍有。</p></li><li><p>分片数（shards）：这是12，表示我们把数据分成多少块存储。</p></li><li><p>主分片数（pri）：primary shards，这里是6，实际上是分片数的两倍，因为有一个副本，如果有两个副本，这里的数量应该是分片数的三倍，这个会跟后面的索引分片数对应起来，这里只是个总数。</p></li><li><p>激活的分片百分比（active_shards_percent）：这里可以理解为加载的数据分片数，只有加载所有的分片数，集群才算正常启动，在启动的过程中，如果我们不断刷新这个页面，我们会发现这个百分比会不断加大。</p></li></ul><p><img src="/img/1.png" srcset="/img/loading.gif" alt="1"></p><h3 id="2-查看集群的索引数"><a href="#2-查看集群的索引数" class="headerlink" title="2. 查看集群的索引数"></a>2. 查看集群的索引数</h3><pre><code>http://127.0.0.1:9200/_cat/indices?v</code></pre><ul><li><p>索引健康（health），green为正常，yellow表示索引不可靠（单节点），red索引不可用。与集群健康状态一致。</p></li><li><p>状态（status），表明索引是否打开。</p></li><li><p>索引名称（index），这里有.kibana和school。</p></li><li><p>uuid，索引内部随机分配的名称，表示唯一标识这个索引。</p></li><li><p>主分片（pri），.kibana为1，school为5，加起来主分片数为6，这个就是集群的主分片数。</p></li><li><p>文档数（docs.count），school在之前的演示添加了两条记录，所以这里的文档数为2。</p></li><li><p>已删除文档数（docs.deleted），这里统计了被删除文档的数量。</p></li><li><p>索引存储的总容量（store.size），这里school索引的总容量为6.4kb，是主分片总容量的两倍，因为存在一个副本。</p></li><li><p>主分片的总容量（pri.store.size），这里school的主分片容量是7kb，是索引总容量的一半。</p></li></ul><p><img src="/img/2.png" srcset="/img/loading.gif" alt="2"></p><h3 id="3-查看集群所在磁盘的分配状况"><a href="#3-查看集群所在磁盘的分配状况" class="headerlink" title="3. 查看集群所在磁盘的分配状况"></a>3. 查看集群所在磁盘的分配状况</h3><pre><code>http://127.0.0.1:9200/_cat/allocation?v</code></pre><p>返回集群中的各节点所在磁盘的磁盘状况。</p><h3 id="4-查看集群的节点"><a href="#4-查看集群的节点" class="headerlink" title="4. 查看集群的节点"></a>4. 查看集群的节点</h3><pre><code>http://127.0.0.1:9200/_cat/nodes?v</code></pre><p>通过该连接返回了集群中各节点的情况。这些信息中比较重要的是master列，带*星号表明该节点是主节点。带-表明该节点是从节点。</p><pre><code>ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name127.0.0.1 19 99 6 2.86 mdi * ruan-node-1127.0.0.1 13 99 6 2.86 mdi - ruan-node-2</code></pre><h3 id="5-查看集群的其它信息"><a href="#5-查看集群的其它信息" class="headerlink" title="5. 查看集群的其它信息"></a>5. 查看集群的其它信息</h3><pre><code>http://127.0.0.1:9200/_cat/</code></pre><p>获得查看集群信息的目录。</p><h3 id="6-全词搜索"><a href="#6-全词搜索" class="headerlink" title="6. 全词搜索"></a>6. 全词搜索</h3><pre><code>http://127.0.0.1:9200/indexName/_search?pretty=true</code></pre><p><code>pretty=true</code> 表示格式化输出。</p><h3 id="7-精准搜索"><a href="#7-精准搜索" class="headerlink" title="7. 精准搜索"></a>7. 精准搜索</h3><pre><code>http://127.0.0.1:9200/indexName/_search?q=123&amp;pretty=true</code></pre><p>表示搜索“123”。</p><h3 id="8-模糊搜索"><a href="#8-模糊搜索" class="headerlink" title="8. 模糊搜索"></a>8. 模糊搜索</h3><pre><code>http://127.0.0.1:9200/indexName/_search?q=*123*&amp;pretty=true</code></pre><p>模糊搜索“123”。</p><h1 id="Kibana-安装"><a href="#Kibana-安装" class="headerlink" title="Kibana 安装"></a>Kibana 安装</h1><h2 id="下载与安装-1"><a href="#下载与安装-1" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>Kibana安装时要注意与ES是同一个版本，ES我的版本是7.6.2，因此Kibana也下载的7.6.2版本的安装包。</p><ul><li>下载地址同官网</li><li>版本：7.6.2</li></ul><p>下载完成后，同样解压到<code>/usr/local/Cellar/</code>路径下。</p><p>进入kibana中的bin目录中，启动：</p><pre><code>$ ./kibana</code></pre><p>Kibana默认端口号<em>5601</em>， 启动成功后，到浏览器输入<code>hocalhost:5601</code>，就能进入Kibana页面了。</p><p>Kibana 7.x版本界面终于做的好看了一些。公司目前用的是5.x版本，界面简单粗暴，看起来总有些怪怪的。</p><p><img src="/img/kibana_cut.png" srcset="/img/loading.gif" alt="3"></p><p><strong>问题：</strong></p><p>在公司安装时，localhost:5601地址可以直接访问Kibana，但是回到家之后再次访问却提示localhost:5601错误，无法访问了，ES也只能通过127.0.0.1:9200才能访问，localhost：9200显示无法连接。</p><p>后来在<code>kibana.yml</code>配置文件里把localhost改成127.0.0.1之后，才能通过127.0.0.1:5601访问，不知道是不是我改动了一些配置？？</p><p>之后再调整一下看看。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先在<code>Management</code>中配置<code>Index Patterns</code>，将想要分析的Index加入进来。</p><p>在<code>Dev Tools</code>里写命令获取数据：</p><pre><code>GET /data_index/_search{  &quot;query&quot;: {    &quot;match_all&quot;: {}  }}</code></pre><p>上面是最简单的获取，Kibana还有其他的Lucene查询语法，可以查询更多的ES数据，按条件查询、搜索等，待实际应用中慢慢学习。</p><p>今天先初步记录安装与使用的信息，以免过后忘记。</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://blog.csdn.net/genghaihua/article/details/81479619" target="_blank" rel="noopener">ES查看集群信息命令</a></em></li><li><em><a href="https://blog.csdn.net/a544258023/article/details/89709046?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2" target="_blank" rel="noopener">ElasticSearch常用查询命令</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kibana</tag>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticdump 踩坑记录</title>
    <link href="/2020/04/02/elasticdump%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/02/elasticdump%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感觉这几天是自己的智商低谷。😭</p></blockquote><h1 id="Elasticdump-安装"><a href="#Elasticdump-安装" class="headerlink" title="Elasticdump 安装"></a>Elasticdump 安装</h1><p>为了解决远程ES数据库导入到本地ES的问题，今天在网上查了一天资料。了解到ELK中的Logstash可以实现这个需求，同时Logstash似乎还隐藏着更多其他炫酷功能，包括我后面可能要用到的web接口。<a id="more"></a> 感觉到这是一个稍微大点的功能，最终决定后面专门腾出时间来研究。</p><p>于是就找到了另外一个非常轻量级的ElasticSearch插件————Elasticdump，专门解决ES数据导入导出的问题。“dump”也是个非常形象的词了，有些简单粗暴，就跟它的实现一样。</p><p>安装Elasticdump很简单，mac上直接 <code>npm install elasticdump</code> 就好了。也可以全剧安装 <code>npm install elasticdump -g</code> 。</p><h1 id="将远程-ES-数据导出到本地-JSON-文件"><a href="#将远程-ES-数据导出到本地-JSON-文件" class="headerlink" title="将远程 ES 数据导出到本地 JSON 文件"></a>将远程 ES 数据导出到本地 JSON 文件</h1><p>这里演示的是我把远程ES上的数据导出到本地的JSON文件。最初的想法是，把远程ES数据导到本地文件，再把文件导入本地的ES。此时，我并没有想到远程ES和本地ES可以直接导入导出，脑子卡在了本地文件里。😓</p><p>实际output部分为本地文件路径，具体如下：</p><pre><code># 格式：$ elasticdump --input {protocol}://{host}:{port}/{index} --output ./test_index.json# 例子：将ES中的test_index 中的索引导出# 导出当前索引的mapping结构$ elasticdump --input http://192.168.56.104:9200/test_index \--output ./test_index_mapping.json --type=mapping# 导出当前索引下的所有真实数据$ elasticdump --input http://192.168.56.104:9200/test_index \--output ./test_index.json --type=data</code></pre><h1 id="将远程的-ES-数据导出到本地-ES"><a href="#将远程的-ES-数据导出到本地-ES" class="headerlink" title="将远程的 ES 数据导出到本地 ES"></a>将远程的 ES 数据导出到本地 ES</h1><p>本地JSON导出之后，终于想到elasticdump明明可以连接远程和本地ES。。。</p><h2 id="无账号密码的情况下导出"><a href="#无账号密码的情况下导出" class="headerlink" title="无账号密码的情况下导出"></a>无账号密码的情况下导出</h2><p>如果远程和本地的ES都不需要账号密码访问权限，相对来说就比较容易，直接遵循下面的格式就可以。</p><p>官方提供的数据迁移示例：</p><pre><code># 拷贝analyzer分词elasticdump \  --input=http://production.es.com:9200/my_index \  --output=http://staging.es.com:9200/my_index \  --type=analyzer</code></pre><pre><code># 拷贝映射elasticdump \  --input=http://production.es.com:9200/my_index \  --output=http://staging.es.com:9200/my_index \  --type=mapping</code></pre><pre><code># 拷贝数据elasticdump \  --input=http://production.es.com:9200/my_index \  --output=http://staging.es.com:9200/my_index \  --type=data</code></pre><h2 id="设置账号密码登录导出"><a href="#设置账号密码登录导出" class="headerlink" title="设置账号密码登录导出"></a>设置账号密码登录导出</h2><p><strong>据说 elasticdump 提供给了–httpAuthFile 参数来做认证</strong></p><pre><code>--httpAuthFile      When using http auth provide credentials in ini file in form                    `user=&lt;username&gt;                    password=&lt;password&gt;`</code></pre><p>只需要写一个ini文件 ，文件中写入用户名和密码就可以了，不过这个方法我还没有试。</p><p>另外一个好的方法是，<strong>在–input参数和–output参数的的url中添加账号密码</strong>。</p><p>例如：</p><pre><code>$ elasticdump --input http://username:passowrd@production.es.com:9200/my_index \--output http://username:password@staging.es.com:9200/my_index \--type=data</code></pre><p>导出mapping</p><pre><code>$ elasticdump --input http://username:password@host:9200/data_index \--output ./test_index.json --type=mapping</code></pre><p>导出所有data</p><pre><code>$ elasticdump --input http://username:password@host:9200/data_index \--output ./test_index_data.json --type=data</code></pre><h2 id="远程-ES-需要账号密码，本地不需要"><a href="#远程-ES-需要账号密码，本地不需要" class="headerlink" title="远程 ES 需要账号密码，本地不需要"></a>远程 ES 需要账号密码，本地不需要</h2><p><strong>上面看起来行云流水一般就能搞定，事实上，对小白来说，好大的坑啊。。。</strong></p><p>折腾完上面的远程ES导出到本地JSON之外，突然发现可以直接从远程ES导入本地ES，为什么我还要拐个弯导出个本地文件，服了我自己的智商。。。</p><p><img src="/img/zhishang1.jpg" srcset="/img/loading.gif" alt="智商"></p><p>由于本地ES没有任何配置，于是我按照示例，最初想到了这样：</p><pre><code>$ elasticdump --input http://username:password@0.0.0.0:9200/data_index \--output http://localhost:9200/data_index --type=mapping</code></pre><p>报错：</p><pre><code>Error Emitted =&gt; {&quot;root_cause&quot;:[{&quot;type&quot;:&quot;mapper_parsing_exception&quot;,&quot;reason&quot;:&quot;Root mapping definition has unsupported parameters:  [kis_data_index_type : {properties={eng_exam_res={type=keyword}, item_state={type=keyword}, first_level={type=text}, chin_exam={analyzer=ik_max_word, type=text}, chinese_item={analyzer=ik_max_word, type=text}, xremark={type=keyword}, eng_synonym={type=keyword}, eng_exam={type=text}, contributor={type=text}, third_level={type=text}, chin_exam_res={type=keyword}, id={type=long}, remark_str={type=keyword}, chin_define_res={type=keyword}, chin_synonym={type=text}, eng_abbr={type=text}, contributor ={type=text, fields={keyword={ignore_above=256, type=keyword}}}, query={properties={match_all={type=object}}}, source_type={type=keyword}, english_item={analyzer=english, type=text}, second_level={type=text}, eng_define_res={type=keyword}, eng_define={type=text}, picture_res={type=keyword}, chin_abbr={type=text}, chin_define={type=text}}}]&quot;}],&quot;type&quot;:&quot;mapper_parsing_exception&quot;,&quot;reason&quot;:&quot;Root mapping definition has unsupported parameters:  [kis_data_index_type : {properties={eng_exam_res={type=keyword}, item_state={type=keyword}, first_level={type=text}, chin_exam={analyzer=ik_max_word, type=text}, chinese_item={analyzer=ik_max_word, type=text}, xremark={type=keyword}, eng_synonym={type=keyword}, eng_exam={type=text}, contributor={type=text}, third_level={type=text}, chin_exam_res={type=keyword}, id={type=long}, remark_str={type=keyword}, chin_define_res={type=keyword}, chin_synonym={type=text}, eng_abbr={type=text}, contributor ={type=text, fields={keyword={ignore_above=256, type=keyword}}}, query={properties={match_all={type=object}}}, source_type={type=keyword}, english_item={analyzer=english, type=text}, second_level={type=text}, eng_define_res={type=keyword}, eng_define={type=text}, picture_res={type=keyword}, chin_abbr={type=text}, chin_define={type=text}}}]&quot;}Error Emitted =&gt; {&quot;root_cause&quot;:[{&quot;type&quot;:&quot;mapper_parsing_exception&quot;,&quot;reason&quot;:&quot;Root mapping definition has unsupported parameters:  [kis_data_index_type : {properties={eng_exam_res={type=keyword}, item_state={type=keyword}, first_level={type=text}, chin_exam={analyzer=ik_max_word, type=text}, chinese_item={analyzer=ik_max_word, type=text}, xremark={type=keyword}, eng_synonym={type=keyword}, eng_exam={type=text}, contributor={type=text}, third_level={type=text}, chin_exam_res={type=keyword}, id={type=long}, remark_str={type=keyword}, chin_define_res={type=keyword}, chin_synonym={type=text}, eng_abbr={type=text}, contributor ={type=text, fields={keyword={ignore_above=256, type=keyword}}}, query={properties={match_all={type=object}}}, source_type={type=keyword}, english_item={analyzer=english, type=text}, second_level={type=text}, eng_define_res={type=keyword}, eng_define={type=text}, picture_res={type=keyword}, chin_abbr={type=text}, chin_define={type=text}}}]&quot;}],&quot;type&quot;:&quot;mapper_parsing_exception&quot;,&quot;reason&quot;:&quot;Root mapping definition has unsupported parameters:  [kis_data_index_type : {properties={eng_exam_res={type=keyword}, item_state={type=keyword}, first_level={type=text}, chin_exam={analyzer=ik_max_word, type=text}, chinese_item={analyzer=ik_max_word, type=text}, xremark={type=keyword}, eng_synonym={type=keyword}, eng_exam={type=text}, contributor={type=text}, third_level={type=text}, chin_exam_res={type=keyword}, id={type=long}, remark_str={type=keyword}, chin_define_res={type=keyword}, chin_synonym={type=text}, eng_abbr={type=text}, contributor ={type=text, fields={keyword={ignore_above=256, type=keyword}}}, query={properties={match_all={type=object}}}, source_type={type=keyword}, english_item={analyzer=english, type=text}, second_level={type=text}, eng_define_res={type=keyword}, eng_define={type=text}, picture_res={type=keyword}, chin_abbr={type=text}, chin_define={type=text}}}]&quot;}</code></pre><p>应该是不能直接用localhost。</p><p>于是我又试了这样：</p><pre><code>$ elasticdump --input http://username:password@0.0.0.0:9200/kis_data_index \--output http://127.0.0.1:9200/data_index --type=mapping</code></pre><p>本机地址，没错吧？</p><p>依然报同样的错误。</p><p>于是，我寻思着是不是应该用电脑无线的IP？(我还加了公司无线网的账号密码。。)</p><pre><code>$ elasticdump --input http://username:password@0.0.0.0:9200/data_index \--output http://OA:password@10.9.1.000:9200/data_index --type=mapping</code></pre><p>这次报错是连不上：</p><pre><code>Thu, 02 Apr 2020 08:01:54 GMT | starting dumpThu, 02 Apr 2020 08:01:54 GMT | got 1 objects from source elasticsearch (offset: 0)Thu, 02 Apr 2020 08:02:14 GMT | Error Emitted =&gt; connect ECONNREFUSED 0.0.0.0:9200Thu, 02 Apr 2020 08:02:14 GMT | Error Emitted =&gt; connect ECONNREFUSED 0.0.0.0:9200Thu, 02 Apr 2020 08:02:14 GMT | Total Writes: 0Thu, 02 Apr 2020 08:02:14 GMT | dump ended with error (get phase) =&gt; Error: connect ECONNREFUSED 0.0.0.0:9200:9200</code></pre><p>把账号密码去了，还是提示连不上。</p><p>这时候我才看到指令最后的 –type=mapping。</p><p>不会是这个指令多余了吧？？</p><p>删掉之后，果然通了。。</p><pre><code>$ elasticdump --input http://username:password@0.0.0.0:9200/data_index \--output http://127.0.0.1:9200/data_index</code></pre><p><strong>妈蛋!</strong><br><strong>被自己气吐血！！</strong></p><pre><code>Thu, 02 Apr 2020 08:24:37 GMT | starting dumpThu, 02 Apr 2020 08:24:37 GMT | got 100 objects from source elasticsearch (offset: 0)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:38 GMT | got 100 objects from source elasticsearch (offset: 100)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:38 GMT | got 100 objects from source elasticsearch (offset: 200)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:38 GMT | got 100 objects from source elasticsearch (offset: 300)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:38 GMT | got 100 objects from source elasticsearch (offset: 400)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:38 GMT | got 100 objects from source elasticsearch (offset: 500)Thu, 02 Apr 2020 08:24:38 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:42 GMT | got 100 objects from source elasticsearch (offset: 600)Thu, 02 Apr 2020 08:24:42 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:42 GMT | got 100 objects from source elasticsearch (offset: 700)Thu, 02 Apr 2020 08:24:43 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:43 GMT | got 100 objects from source elasticsearch (offset: 800)Thu, 02 Apr 2020 08:24:43 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:43 GMT | got 100 objects from source elasticsearch (offset: 900)Thu, 02 Apr 2020 08:24:43 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:43 GMT | got 100 objects from source elasticsearch (offset: 1000)Thu, 02 Apr 2020 08:24:43 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:48 GMT | got 100 objects from source elasticsearch (offset: 1100)Thu, 02 Apr 2020 08:24:48 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:48 GMT | got 100 objects from source elasticsearch (offset: 1200)Thu, 02 Apr 2020 08:24:48 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:48 GMT | got 100 objects from source elasticsearch (offset: 1300)Thu, 02 Apr 2020 08:24:48 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:48 GMT | got 100 objects from source elasticsearch (offset: 1400)Thu, 02 Apr 2020 08:24:48 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:48 GMT | got 100 objects from source elasticsearch (offset: 1500)Thu, 02 Apr 2020 08:24:48 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:52 GMT | got 100 objects from source elasticsearch (offset: 1600)Thu, 02 Apr 2020 08:24:52 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:53 GMT | got 100 objects from source elasticsearch (offset: 1700)Thu, 02 Apr 2020 08:24:53 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:53 GMT | got 100 objects from source elasticsearch (offset: 1800)Thu, 02 Apr 2020 08:24:53 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:53 GMT | got 100 objects from source elasticsearch (offset: 1900)Thu, 02 Apr 2020 08:24:53 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:24:53 GMT | got 100 objects from source elasticsearch (offset: 2000)Thu, 02 Apr 2020 08:24:53 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2100)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2200)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2300)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2400)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2500)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:08 GMT | got 100 objects from source elasticsearch (offset: 2600)Thu, 02 Apr 2020 08:25:08 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:13 GMT | got 100 objects from source elasticsearch (offset: 2700)Thu, 02 Apr 2020 08:25:13 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:13 GMT | got 100 objects from source elasticsearch (offset: 2800)Thu, 02 Apr 2020 08:25:13 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:13 GMT | got 100 objects from source elasticsearch (offset: 2900)Thu, 02 Apr 2020 08:25:13 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:13 GMT | got 100 objects from source elasticsearch (offset: 3000)Thu, 02 Apr 2020 08:25:13 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:13 GMT | got 100 objects from source elasticsearch (offset: 3100)Thu, 02 Apr 2020 08:25:13 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:18 GMT | got 100 objects from source elasticsearch (offset: 3200)Thu, 02 Apr 2020 08:25:18 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:18 GMT | got 100 objects from source elasticsearch (offset: 3300)Thu, 02 Apr 2020 08:25:18 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:18 GMT | got 100 objects from source elasticsearch (offset: 3400)Thu, 02 Apr 2020 08:25:18 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:18 GMT | got 100 objects from source elasticsearch (offset: 3500)Thu, 02 Apr 2020 08:25:18 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:18 GMT | got 100 objects from source elasticsearch (offset: 3600)Thu, 02 Apr 2020 08:25:18 GMT | sent 100 objects to destination elasticsearch, wrote 100Thu, 02 Apr 2020 08:25:23 GMT | got 35 objects from source elasticsearch (offset: 3700)Thu, 02 Apr 2020 08:25:23 GMT | sent 35 objects to destination elasticsearch, wrote 35Thu, 02 Apr 2020 08:25:23 GMT | got 0 objects from source elasticsearch (offset: 3735)Thu, 02 Apr 2020 08:25:23 GMT | Total Writes: 3735Thu, 02 Apr 2020 08:25:23 GMT | dump complete</code></pre><p>不过，我在网上研究的时候，看到示例中都有指定–type=XXX，mapping和data要分别指定。后边需要验证一下不指定–type的情况下，导入到本地ES的文件是不是同时包含了mapping和所有data数据（从导入的记录上看，确实完整导入了3735条数据）。</p><hr><p><strong>2020-04-03 补充：</strong></p><p>后来想到，–type无法访问可能是因为index指定的问题，后边遇到搜索查询数据的时候，再研究一下。</p>]]></content>
    
    
    <categories>
      
      <category>ELK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识点（一）：MVVM模型</title>
    <link href="/2020/03/23/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"/>
    <url>/2020/03/23/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>在学习Vue的过程中，最先遇到的就是MVVM、耦合、解耦的概念，在这里用“知识点”的分类总结一下。</p><p>知识点的帖子应该会不断增加，积少成多做成一个系列，慢慢充实起来。<a id="more"></a></p><hr><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM是Model-View-ViewModel的缩写，一种前端开发的模型。主要思想是，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大程度的分离。</p><p>在MVVM架构下，View和Model之间没有直接的联系，而是通过ViewModel来交互，View数据的变化会同步到Model中，Model数据的变化也会立即反应到View上。</p><p><img src="/img/mvvm2.png" srcset="/img/loading.gif" alt="mvvm"></p><br><p>一个MVVM框架和传统JS、jQuery操作DOM的区别是什么？</p><h3 id="传统-JS-操作DOM"><a href="#传统-JS-操作DOM" class="headerlink" title="传统 JS 操作DOM"></a>传统 JS 操作DOM</h3><p>传统的JS直接写代码逻辑去操作DOM，原生JS：</p><pre><code class="html">&lt;!-- HTML --&gt;&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;</code></pre><pre><code class="js">var dom = document.getElementById(&#39;name&#39;);dom.innerHTML = &#39;Sansan&#39;;dom.style.color = &#39;red&#39;</code></pre><h3 id="jQuery-修改-DOM"><a href="#jQuery-修改-DOM" class="headerlink" title="jQuery 修改 DOM"></a>jQuery 修改 DOM</h3><pre><code class="html">&lt;!-- HTML --&gt;&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;</code></pre><p>用 jQuery 修改 DOM：</p><pre><code class="js">$(&#39;#name&#39;).text(&quot;Sansan&quot;).css(&quot;color&quot;, &quot;red&quot;);</code></pre><p>jQuery中数据处理的逻辑和视图混合在一起，并未分离。</p><h3 id="MVVM-修改-DOM"><a href="#MVVM-修改-DOM" class="headerlink" title="MVVM 修改 DOM"></a>MVVM 修改 DOM</h3><p>只需要关注数据结构，由 ViewModel 进行双向绑定数据操作：</p><pre><code class="html">&lt;!-- HTML --&gt;&lt;div id=&quot;app&quot;&gt;    &lt;input v-model=&quot;name&quot; /&gt;    &lt;span&gt;姓名:{{name}}&lt;/span&gt;    &lt;span&gt;年龄:{{age}}&lt;/span&gt;&lt;/div&gt;</code></pre><p>Vue.js</p><pre><code class="js">var app = new Vue({    el: &#39;#app&#39;,    data: {        name: &#39;Sansan&#39;,        age: 20    }})</code></pre><p>Vue.js 将数据视图分离，以数据驱动视图，只关心数据变化，DOM操作被封装。</p><h2 id="耦合与解耦"><a href="#耦合与解耦" class="headerlink" title="耦合与解耦"></a>耦合与解耦</h2><h3 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h3><p>软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间耦合越高，维护成本越高，因此对象的设计应该使类和构件之间的耦合最小。耦合性用来衡量程序结构中各个模块之间的相互关联，同时取决于各个模块之间接口的复杂程度、调用模块的方式是什么，以及哪些信息通过接口。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>解耦即尽可能减少代码之间的耦合，数据、业务和视图之间尽可能的降低耦合。</p><p>原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。</p><p>在Vue中，解耦即将<strong>视图</strong>与<strong>数据</strong>分成两部分，即<strong>视图代码</strong>与<strong>业务逻辑</strong>的解耦。</p><hr><p><strong>参考来源：</strong></p><ul><li><em><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072" target="_blank" rel="noopener">廖雪峰的官方网站</a></em></li><li><em><a href="https://blog.csdn.net/zhanghuali0210/article/details/82287544?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">vue考点 —— MVVM</a></em></li><li><em><a href="https://blog.csdn.net/u012551928/article/details/99545791" target="_blank" rel="noopener">MVVM模型</a></em></li><li><em><a href="https://blog.csdn.net/shenwansan_gz/article/details/82284957" target="_blank" rel="noopener">什么是耦合、解耦</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拥抱VS Code，抛弃Atom</title>
    <link href="/2020/03/20/vscode/"/>
    <url>/2020/03/20/vscode/</url>
    
    <content type="html"><![CDATA[<blockquote><p>没捣鼓过几个代码编辑器，都不好意思说自己写过代码。</p></blockquote><p>留学的时候，因为开源和颜值，爱上了Atom，期间不管它多少次龟速加载我都毫无怨言，teletype好用，暗黑主题真香。<a id="more"></a> 至于Sublime Text，因为当初觉得界面太丑，用了一次就放弃了。</p><p>可是，前几天看到VS Code、Sublime和Atom的趋势图，VS Code的势头在这两年增长很迅猛。经过两年的更新之后，VS Code的功能已经非常健全，加上速度快不卡顿，再加上还能下载Atom的主题插件，于是我就叛逃到VS Code，卸载了Atom 🙈。</p><p>经过一番折腾，记录下目前觉得实用的插件：</p><h2 id="One-Dark-Pro主题"><a href="#One-Dark-Pro主题" class="headerlink" title="One Dark Pro主题"></a>One Dark Pro主题</h2><p><img src="/img/one_dark_pro.jpg" srcset="/img/loading.gif" alt="主题"></p><p>Atom里我最爱的主题，留学期间的作业都是依靠这简洁而又不做作的主题，给我了无数次爬起来修复bug的力量。暗黑主题，配色很舒服，我个人非常喜欢。</p><p>One Dark Pro这个主题的配色，相比原版要稍微鲜艳一些，看了一下配置文件里的颜色代码一致，但呈现出来的效果却有一些差别。自己捣鼓了几版配色觉得还是不太满意，暂且先用默认的了。部分类别配色的设置红色偏多，稍稍做了一些修改，显得整体的红配绿不那么突兀。</p><h2 id="Color-Highlight"><a href="#Color-Highlight" class="headerlink" title="Color Highlight"></a>Color Highlight</h2><p>这个插件可以把颜色代码显示出对应的颜色，不需要依靠页面预览才能看到效果，调试CSS配色的时候更加方便，节省时间。</p><h2 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h2><img src="/img/live.jpg" srcset="/img/loading.gif" width="30%"><p>如果是前端开发，这个插件就很有用了，可以在浏览器实时显示HTML页面。最近在学习Vue，简单的例子都可以在网页里localhost实时预览，不要太方便。</p><h2 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h2><p>如果学习Vue，这个插件就是必备了。另外还需要一些其他的配置，后面Vue学习的部分再来细说。</p><p>另外还有代码格式美化、minimap（自带）、terminal（自带）都是编辑器里很好的助手。必需的插件配置好之后，就可以愉快的coding了。另外，VS Code也支持Python相关的环境配置，比如Jupyter Notebook之类的，我暂时还没尝试。</p><p>初步体验下来，VS Code确实像You大说的一样，真香。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年的一些计划</title>
    <link href="/2020/01/08/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/"/>
    <url>/2020/01/08/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>经过一天的时间搭建Hexo，我的个人博客地址有个了雏形，目前还在找背景图片的阶段，再过几天才能整成想要的样子。</p><p>不得不说，Hexo这类工具真的蛮好用，虽然前期花时间部署比较费劲，但是呈现的效果还是非常不错的，再加上自己可以在原有主题的基础上不断折腾，也是乐趣所在。</p><a id="more"></a><p>第一篇博客主要想把2020年我的计划写下来，经常翻看，保持计划的进度。</p><h2 id="2020年计划"><a href="#2020年计划" class="headerlink" title="2020年计划"></a>2020年计划</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>2020年的计划主要是四个方面：</p><ol><li>搭建个人技术博客 （进行中）</li><li>完成一个数据可视化网站项目</li><li>完成一个微信小程序项目</li><li>微信号/百家号</li></ol><p>希望能在今年把这四件事情按顺序一一搭建起来，即使无法做到完成，也希望能开始行动起来，先找到idea，再把整体思路和框架梳理出来。</p><h3 id="关于个人技术博客"><a href="#关于个人技术博客" class="headerlink" title="关于个人技术博客"></a>关于个人技术博客</h3><p>这部分一直想做，但是没腾出时间来好好研究。最开始还是以WordPress来研究，但由于当时觉得部署麻烦，就没继续。后来做了前端的一些项目之后，生出了自己开发博客网站的想法，无意中在知乎上看到了现在已经如此普遍的Hexo、Hugo等等工具，茅塞顿开。这正是我想要的么！</p><p>那为什么没选Hugo？由于Hexo是基于JavaScript的，Hugo是基于Go语言的，前者对我来说更加熟悉，如果想要在原有基础上折腾，也有很多可以发挥的空间，于是就开开心心地花了一天时间部署到了GitHub Page上。基础工作就算完成了。</p><p>第一版的大概长这样：</p><p><img src="/img/3.jpg" srcset="/img/loading.gif" alt="界面"></p><p>熟悉的 “Hello World”。</p><p>接下来就是确定一下更新的计划了。博客基本根据个人的学习情况和前端开发项目的进展情况来更新，知识的总结、遇到的问题以及其他的感悟放到这上面，作为记录。好记性不如烂笔头。</p><h3 id="关于数据可视化网站项目"><a href="#关于数据可视化网站项目" class="headerlink" title="关于数据可视化网站项目"></a>关于数据可视化网站项目</h3><p>元旦的时候，我原本想把之前写的一个爬虫程序抓到的数据作为这个项目的数据源，不过因为爬虫过程还不完善，而且有些地方仍然需要手动干预，所以关于这个项目的构想就暂时搁置了。</p><p>仔细想想，抛开爬虫实时抓取的需求，仅仅把过往累积的数据拿出来做展示也未尝不可。只不过这样一来，没有办法与爬虫程序整合，只能依靠本地抓取到的数据进行可视化，交互性和功能性会差很多。</p><p>春节期间，再好好考虑一下这个项目。</p><h3 id="关于微信小程序项目"><a href="#关于微信小程序项目" class="headerlink" title="关于微信小程序项目"></a>关于微信小程序项目</h3><p>这个项目需要整体学习小程序开发的语言，目前面临几个问题：第一，开发什么，目前还没有认真思考过，没有清晰的idea；第二，其他的项目在前，这个项目可能要往后面排了，现在时间精力都没办法让我好好想关于这个项目的东西。</p><p>所以，Flag就先立在这吧，回头再来拔。。</p><h3 id="微信号-百家号"><a href="#微信号-百家号" class="headerlink" title="微信号/百家号"></a>微信号/百家号</h3><p>自媒体这部分其实开始了很长时间，但是没能坚持下来，断断续续更新，还没得原创头衔，稍显动力不足。</p><p>春节期间的计划是，拿另一个身份重新注册一个公众号，把百家号上发过的文章拿到公众号的平台上重新发一遍。</p><p>其次，争取恢复百家号的日常更新，考虑到自己犯懒，先定在每周末更新一到两篇。</p><p>每年都是Flag自豪的立起来，年终的时候大部分倒下。可能这就是三三同学生活的常态吧。可三三同学也不应该当一条咸鱼，还是要奋力折腾啊！</p><p><strong>がんばって！</strong></p>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
